{"file":"C:\\Users\\ti198\\investment_analysis_opopo\\src\\utils\\rate-limiter.ts","mappings":";AAAA;;;;;;;;;;;;;;;;;;;GAmBG;;;AAEH,qCAAkC;AAalC;;;;;GAKG;AACH,MAAa,WAAW;IACZ,eAAe,GAAkB,IAAI,CAAC;IACtC,UAAU,CAAS;IAE3B;;;;OAIG;IACH,YAAY,UAA8B,EAAE,UAAU,EAAE,IAAI,EAAE;QAC1D,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;IACzC,CAAC;IAED;;;;;;;;;;;;;;;;;OAiBG;IACH,KAAK,CAAC,YAAY;QACd,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI,EAAE,CAAC;YAChC,iBAAiB;YACjB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAClC,eAAM,CAAC,KAAK,CAAC,uCAAuC,CAAC,CAAC;YACtD,OAAO;QACX,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC;QAClD,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;QAExC,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;YACZ,4BAA4B;YAC5B,eAAM,CAAC,KAAK,CAAC,wBAAwB,EAAE;gBACnC,QAAQ,EAAE,KAAK;gBACf,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,OAAO;aACV,CAAC,CAAC;YACH,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACtC,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,KAAK;QACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,aAAa;QACT,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACH,kBAAkB;QACd,OAAO,IAAI,CAAC,eAAe,CAAC;IAChC,CAAC;CACJ;AA1FD,kCA0FC","names":[],"sources":["C:\\Users\\ti198\\investment_analysis_opopo\\src\\utils\\rate-limiter.ts"],"sourcesContent":["/**\r\n * RateLimiter - リクエストレート制限クラス\r\n * \r\n * TDnetへのリクエストを適切に制限し、過度な負荷をかけないようにする。\r\n * 連続リクエスト間で最小遅延時間を確保する。\r\n * \r\n * Steering準拠:\r\n * - development/tdnet-scraping-patterns.md: レート制限実装パターン\r\n * - core/error-handling-patterns.md: 構造化ログの記録\r\n * \r\n * @example\r\n * ```typescript\r\n * const rateLimiter = new RateLimiter({ minDelayMs: 2000 });\r\n * \r\n * for (const url of urls) {\r\n *     await rateLimiter.waitIfNeeded();\r\n *     const data = await fetchData(url);\r\n * }\r\n * ```\r\n */\r\n\r\nimport { logger } from './logger';\r\n\r\n/**\r\n * RateLimiterのオプション\r\n */\r\nexport interface RateLimiterOptions {\r\n    /**\r\n     * 最小遅延時間（ミリ秒）\r\n     * @default 2000\r\n     */\r\n    minDelayMs: number;\r\n}\r\n\r\n/**\r\n * レート制限を管理するクラス\r\n * \r\n * 連続リクエスト間で最小遅延時間を確保し、\r\n * 外部サービスへの過度な負荷を防ぐ。\r\n */\r\nexport class RateLimiter {\r\n    private lastRequestTime: number | null = null;\r\n    private minDelayMs: number;\r\n\r\n    /**\r\n     * RateLimiterを初期化\r\n     * \r\n     * @param options - レート制限のオプション\r\n     */\r\n    constructor(options: RateLimiterOptions = { minDelayMs: 2000 }) {\r\n        this.minDelayMs = options.minDelayMs;\r\n    }\r\n\r\n    /**\r\n     * リクエスト前に呼び出し、必要に応じて待機する\r\n     * \r\n     * 最後のリクエストから最小遅延時間が経過していない場合、\r\n     * 残り時間だけ待機する。\r\n     * \r\n     * Steering準拠: 構造化ログを記録（development/tdnet-scraping-patterns.md）\r\n     * \r\n     * @returns Promise<void>\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * const rateLimiter = new RateLimiter({ minDelayMs: 2000 });\r\n     * \r\n     * await rateLimiter.waitIfNeeded(); // 最初のリクエスト（即座に実行）\r\n     * await rateLimiter.waitIfNeeded(); // 2回目のリクエスト（2000ms待機）\r\n     * ```\r\n     */\r\n    async waitIfNeeded(): Promise<void> {\r\n        if (this.lastRequestTime === null) {\r\n            // 最初のリクエストは即座に実行\r\n            this.lastRequestTime = Date.now();\r\n            logger.debug('Rate limiter: first request, no delay');\r\n            return;\r\n        }\r\n\r\n        const elapsed = Date.now() - this.lastRequestTime;\r\n        const delay = this.minDelayMs - elapsed;\r\n\r\n        if (delay > 0) {\r\n            // 最小遅延時間が経過していない場合、残り時間だけ待機\r\n            logger.debug('Rate limiting: waiting', {\r\n                waitTime: delay,\r\n                minDelayMs: this.minDelayMs,\r\n                elapsed,\r\n            });\r\n            await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n\r\n        this.lastRequestTime = Date.now();\r\n    }\r\n\r\n    /**\r\n     * 最後のリクエスト時刻をリセット\r\n     * \r\n     * リセット後の最初のリクエストは即座に実行される。\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * const rateLimiter = new RateLimiter({ minDelayMs: 2000 });\r\n     * \r\n     * await rateLimiter.waitIfNeeded(); // 最初のリクエスト\r\n     * rateLimiter.reset(); // リセット\r\n     * await rateLimiter.waitIfNeeded(); // リセット後の最初のリクエスト（即座に実行）\r\n     * ```\r\n     */\r\n    reset(): void {\r\n        this.lastRequestTime = null;\r\n    }\r\n\r\n    /**\r\n     * 最小遅延時間を取得\r\n     * \r\n     * @returns 最小遅延時間（ミリ秒）\r\n     */\r\n    getMinDelayMs(): number {\r\n        return this.minDelayMs;\r\n    }\r\n\r\n    /**\r\n     * 最後のリクエスト時刻を取得\r\n     * \r\n     * @returns 最後のリクエスト時刻（Unix時刻）、またはnull（リクエスト未実行）\r\n     */\r\n    getLastRequestTime(): number | null {\r\n        return this.lastRequestTime;\r\n    }\r\n}\r\n"],"version":3}
/**
 * Lambda Collect Handler Tests
 *
 * POST /collect 繧ｨ繝ｳ繝峨・繧､繝ｳ繝医・繝ｦ繝九ャ繝医ユ繧ｹ繝・
 */

import { APIGatewayProxyEvent, Context } from 'aws-lambda';
import { handler } from '../handler';
import { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';
import { mockClient } from 'aws-sdk-client-mock';

// AWS SDK Mocks
const lambdaMock = mockClient(LambdaClient);
const secretsMock = mockClient(SecretsManagerClient);

// Mock Context
const mockContext: Context = {
  callbackWaitsForEmptyEventLoop: false,
  functionName: 'tdnet-collect',
  functionVersion: '1',
  invokedFunctionArn: 'arn:aws:lambda:ap-northeast-1:123456789012:function:tdnet-collect',
  memoryLimitInMB: '256',
  awsRequestId: 'test-request-id-12345',
  logGroupName: '/aws/lambda/tdnet-collect',
  logStreamName: '2024/01/15/[$LATEST]abcdef',
  getRemainingTimeInMillis: () => 30000,
  done: () => {},
  fail: () => {},
  succeed: () => {},
};

/**
 * 繝・せ繝育畑縺ｮ譌･莉倥ｒ蜍慕噪縺ｫ逕滓・
 * 迴ｾ蝨ｨ譌･縺九ｉ逶ｸ蟇ｾ逧・↑譌･莉倥ｒ霑斐☆縺薙→縺ｧ縲√ユ繧ｹ繝医′蟶ｸ縺ｫ譛牙柑縺ｪ譌･莉倡ｯ・峇繧剃ｽｿ逕ｨ縺ｧ縺阪ｋ繧医≧縺ｫ縺吶ｋ
 */
const getTestDates = () => {
  const today = new Date();
  const startDate = new Date(today);
  startDate.setDate(startDate.getDate() - 7); // 7譌･蜑・
  const endDate = new Date(today);
  endDate.setDate(endDate.getDate() - 2); // 2譌･蜑・
  
  return {
    start_date: startDate.toISOString().split('T')[0],
    end_date: endDate.toISOString().split('T')[0],
  };
};

/**
 * 謖・ｮ壽律謨ｰ蜑阪・譌･莉倥ｒ蜿門ｾ・
 */
const getDaysAgo = (days: number): string => {
  const date = new Date();
  date.setDate(date.getDate() - days);
  return date.toISOString().split('T')[0];
};

/**
 * 謖・ｮ壽律謨ｰ蠕後・譌･莉倥ｒ蜿門ｾ・
 */
const getDaysLater = (days: number): string => {
  const date = new Date();
  date.setDate(date.getDate() + days);
  return date.toISOString().split('T')[0];
};

/**
 * 繝・せ繝育畑縺ｮAPIGatewayProxyEvent繧剃ｽ懈・
 */
const createTestEvent = (body: any, apiKey: string = 'test-api-key-12345'): APIGatewayProxyEvent => {
  return {
    body: JSON.stringify(body),
    headers: {
      'x-api-key': apiKey,
    },
    multiValueHeaders: {},
    httpMethod: 'POST',
    isBase64Encoded: false,
    path: '/collect',
    pathParameters: null,
    queryStringParameters: null,
    multiValueQueryStringParameters: null,
    stageVariables: null,
    requestContext: {} as any,
    resource: '',
  };
};

describe('POST /collect Handler', () => {
  beforeEach(() => {
    lambdaMock.reset();
    process.env.COLLECTOR_FUNCTION_NAME = 'tdnet-collector';
    process.env.AWS_REGION = 'ap-northeast-1';
  });

  afterEach(() => {
    delete process.env.COLLECTOR_FUNCTION_NAME;
    delete process.env.AWS_REGION;
  });

  describe('豁｣蟶ｸ邉ｻ', () => {
    it('譛牙柑縺ｪ繝ｪ繧ｯ繧ｨ繧ｹ繝医〒200繧定ｿ斐☆', async () => {
      // Lambda Collector縺ｮ蜻ｼ縺ｳ蜃ｺ縺励ｒ繝｢繝・け・亥酔譛溷他縺ｳ蜃ｺ縺暦ｼ・
      const mockCollectorResponse = {
        execution_id: 'exec_1234567890_abc123_test1234',
        status: 'success',
        message: 'Collection started',
        collected_count: 0,
        failed_count: 0,
      };

      lambdaMock.on(InvokeCommand).resolves({
        StatusCode: 200,
        Payload: Buffer.from(JSON.stringify(mockCollectorResponse)),
      });

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(200);
      expect(result.headers?.['Content-Type']).toBe('application/json');
      expect(result.headers?.['Access-Control-Allow-Origin']).toBe('*');

      const body = JSON.parse(result.body);
      expect(body.status).toBe('success');
      expect(body.data).toHaveProperty('execution_id');
      expect(body.data).toHaveProperty('status', 'pending');
      expect(body.data).toHaveProperty('message');
      expect(body.data).toHaveProperty('started_at');
    });

    it('Lambda Collector縺九ｉ霑斐＆繧後◆execution_id繧剃ｽｿ逕ｨ縺吶ｋ', async () => {
      const mockCollectorResponse = {
        execution_id: 'exec_1234567890_abc123_test1234',
        status: 'success',
        message: 'Collection started',
        collected_count: 0,
        failed_count: 0,
      };

      lambdaMock.on(InvokeCommand).resolves({
        StatusCode: 200,
        Payload: Buffer.from(JSON.stringify(mockCollectorResponse)),
      });

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      const result = await handler(event, mockContext);
      const body = JSON.parse(result.body);

      // Lambda Collector縺九ｉ霑斐＆繧後◆execution_id縺御ｽｿ逕ｨ縺輔ｌ縺ｦ縺・ｋ縺薙→繧堤｢ｺ隱・
      expect(body.data.execution_id).toBe('exec_1234567890_abc123_test1234');
    });

    it('Lambda蜻ｼ縺ｳ蜃ｺ縺励′RequestResponse繝｢繝ｼ繝峨〒螳溯｡後＆繧後ｋ', async () => {
      const mockCollectorResponse = {
        execution_id: 'exec_1234567890_abc123_test1234',
        status: 'success',
        message: 'Collection started',
        collected_count: 0,
        failed_count: 0,
      };

      lambdaMock.on(InvokeCommand).resolves({
        StatusCode: 200,
        Payload: Buffer.from(JSON.stringify(mockCollectorResponse)),
      });

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      await handler(event, mockContext);

      // InvokeCommand縺梧ｭ｣縺励＞繝代Λ繝｡繝ｼ繧ｿ縺ｧ蜻ｼ縺ｰ繧後◆縺薙→繧堤｢ｺ隱・
      const calls = lambdaMock.commandCalls(InvokeCommand);
      expect(calls.length).toBe(1);
      expect(calls[0].args[0].input.InvocationType).toBe('RequestResponse');
      expect(calls[0].args[0].input.FunctionName).toBe('tdnet-collector');
    });
  });

  describe('繝舌Μ繝・・繧ｷ繝ｧ繝ｳ繧ｨ繝ｩ繝ｼ', () => {
    it('繝ｪ繧ｯ繧ｨ繧ｹ繝医・繝・ぅ縺後↑縺・ｴ蜷医・400繧定ｿ斐☆', async () => {
      const event = createTestEvent(null);

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.status).toBe('error');
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('Request body is required');
    });

    it('start_date縺後↑縺・ｴ蜷医・400繧定ｿ斐☆', async () => {
      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          end_date: getDaysAgo(2),
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('start_date is required');
    });

    it('end_date縺後↑縺・ｴ蜷医・400繧定ｿ斐☆', async () => {
      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          start_date: getDaysAgo(7),
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('end_date is required');
    });

    it('start_date縺ｮ繝輔か繝ｼ繝槭ャ繝医′荳肴ｭ｣縺ｪ蝣ｴ蜷医・400繧定ｿ斐☆', async () => {
      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          start_date: '2024/01/15', // 荳肴ｭ｣縺ｪ繝輔か繝ｼ繝槭ャ繝・
          end_date: getDaysAgo(2),
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('Invalid start_date format');
    });

    it('start_date縺悟ｭ伜惠縺励↑縺・律莉倥・蝣ｴ蜷医・400繧定ｿ斐☆', async () => {
      // 蟄伜惠縺励↑縺・律莉倥ｒ菴ｿ逕ｨ・・譛・0譌･縺ｯ蟄伜惠縺励↑縺・ｼ・
      // 縺溘□縺励・蟷ｴ莉･蜀・・譌･莉倥ｒ菴ｿ逕ｨ縺吶ｋ蠢・ｦ√′縺ゅｋ
      const today = new Date();
      const year = today.getFullYear();
      const month = today.getMonth() + 1; // 迴ｾ蝨ｨ縺ｮ譛・
      
      const event = createTestEvent({
          start_date: `${year}-02-30`, // 2譛・0譌･縺ｯ蟄伜惠縺励↑縺・
          end_date: `${year}-03-01`,
        });

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      // 譌･莉倥・謨ｴ蜷域ｧ繝√ぉ繝・け縺ｧ辟｡蜉ｹ縺ｪ譌･莉倥ｒ讀懷・
      expect(body.error.message).toContain('Invalid start_date');
    });

    it('start_date縺憩nd_date繧医ｊ蠕後・蝣ｴ蜷医・400繧定ｿ斐☆', async () => {
      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          start_date: getDaysAgo(2),
          end_date: getDaysAgo(7),
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('must be before or equal to');
    });

    it('start_date縺・蟷ｴ莉･荳雁燕縺ｮ蝣ｴ蜷医・400繧定ｿ斐☆', async () => {
      const twoYearsAgo = getDaysAgo(730); // 2蟷ｴ蜑・

      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          start_date: twoYearsAgo,
          end_date: getDaysAgo(2),
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('too old');
    });

    it('end_date縺梧悴譚･譌･縺ｮ蝣ｴ蜷医・400繧定ｿ斐☆', async () => {
      const twoDaysLater = getDaysLater(2); // 2譌･蠕・

      const event: APIGatewayProxyEvent = {
        body: JSON.stringify({
          start_date: getDaysAgo(7),
          end_date: twoDaysLater,
        }),
        headers: {},
        multiValueHeaders: {},
        httpMethod: 'POST',
        isBase64Encoded: false,
        path: '/collect',
        pathParameters: null,
        queryStringParameters: null,
        multiValueQueryStringParameters: null,
        stageVariables: null,
        requestContext: {} as any,
        resource: '',
      };

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(400);
      const body = JSON.parse(result.body);
      expect(body.error.code).toBe('VALIDATION_ERROR');
      expect(body.error.message).toContain('cannot be in the future');
    });
  });

  describe('Lambda蜻ｼ縺ｳ蜃ｺ縺励お繝ｩ繝ｼ', () => {
    it('Lambda Collector縺ｮ蜻ｼ縺ｳ蜃ｺ縺励↓螟ｱ謨励＠縺溷ｴ蜷医・500繧定ｿ斐☆', async () => {
      lambdaMock.on(InvokeCommand).rejects(new Error('Lambda invocation failed'));

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(500);
      const body = JSON.parse(result.body);
      expect(body.status).toBe('error');
      expect(body.error.code).toBe('INTERNAL_ERROR');
      expect(body.error.message).toContain('Failed to start data collection');
    });

    it('Lambda Collector縺檎ｩｺ縺ｮPayload繧定ｿ斐＠縺溷ｴ蜷医・500繧定ｿ斐☆', async () => {
      lambdaMock.on(InvokeCommand).resolves({
        StatusCode: 200,
        Payload: undefined,
      });

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(500);
      const body = JSON.parse(result.body);
      expect(body.status).toBe('error');
      expect(body.error.code).toBe('INTERNAL_ERROR');
    });

    it('Lambda Collector縺憩xecution_id繧定ｿ斐＆縺ｪ縺・ｴ蜷医・500繧定ｿ斐☆', async () => {
      const mockCollectorResponse = {
        status: 'success',
        message: 'Collection started',
        collected_count: 0,
        failed_count: 0,
        // execution_id縺後↑縺・
      };

      lambdaMock.on(InvokeCommand).resolves({
        StatusCode: 200,
        Payload: Buffer.from(JSON.stringify(mockCollectorResponse)),
      });

      const testDates = getTestDates();
      const event = createTestEvent(testDates);

      const result = await handler(event, mockContext);

      expect(result.statusCode).toBe(500);
      const body = JSON.parse(result.body);
      expect(body.status).toBe('error');
      expect(body.error.code).toBe('INTERNAL_ERROR');
    });
  });
});

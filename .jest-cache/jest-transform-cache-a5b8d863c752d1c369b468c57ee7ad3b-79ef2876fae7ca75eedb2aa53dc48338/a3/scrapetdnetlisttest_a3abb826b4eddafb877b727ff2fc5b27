17d1d6a90fd267485e60dfc7689c5015
"use strict";
/**
 * TDnet List Scraper - Unit Tests
 *
 * Requirements: 要件1.1, 9.1
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies
jest.mock('axios');
jest.mock('../../../scraper/html-parser');
jest.mock('../../../utils/rate-limiter');
const axios_1 = __importDefault(require("axios"));
const scrape_tdnet_list_1 = require("../scrape-tdnet-list");
const html_parser_1 = require("../../../scraper/html-parser");
const rate_limiter_1 = require("../../../utils/rate-limiter");
const errors_1 = require("../../../errors");
const mockAxios = axios_1.default;
const mockParseDisclosureList = html_parser_1.parseDisclosureList;
const MockRateLimiter = rate_limiter_1.RateLimiter;
describe('scrapeTdnetList', () => {
    let mockRateLimiterInstance;
    beforeEach(() => {
        jest.clearAllMocks();
        // Mock RateLimiter instance
        mockRateLimiterInstance = {
            waitIfNeeded: jest.fn().mockResolvedValue(undefined),
            reset: jest.fn(),
            getMinDelayMs: jest.fn().mockReturnValue(2000),
            getLastRequestTime: jest.fn().mockReturnValue(null),
        };
        MockRateLimiter.mockImplementation(() => mockRateLimiterInstance);
    });
    describe('Success Cases', () => {
        it('should successfully scrape TDnet list', async () => {
            const mockHtml = '<html><body>Test HTML</body></html>';
            const mockDisclosures = [
                {
                    company_code: '1234',
                    company_name: 'Test Company',
                    disclosure_type: '決算短信',
                    title: 'Test Disclosure',
                    disclosed_at: '2024-01-15T01:30:00Z',
                    pdf_url: 'https://example.com/test.pdf',
                },
            ];
            mockAxios.get.mockResolvedValue({
                data: mockHtml,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue(mockDisclosures);
            const result = await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(result).toEqual(mockDisclosures);
            expect(mockRateLimiterInstance.waitIfNeeded).toHaveBeenCalled();
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('2024-01-15'), expect.objectContaining({
                timeout: 30000,
                headers: expect.objectContaining({
                    'User-Agent': expect.stringContaining('TDnet-Data-Collector'),
                }),
            }));
            expect(mockParseDisclosureList).toHaveBeenCalledWith(mockHtml);
        });
        it('should apply rate limiting before each request', async () => {
            const mockHtml = '<html><body>Test HTML</body></html>';
            mockAxios.get.mockResolvedValue({
                data: mockHtml,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            // Verify rate limiter was called
            expect(mockRateLimiterInstance.waitIfNeeded).toHaveBeenCalled();
            // Verify axios.get was called after rate limiter
            expect(mockAxios.get).toHaveBeenCalled();
        });
    });
    describe('Validation', () => {
        describe('Date Format Validation', () => {
            it('should reject invalid date format - slash separator', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024/01/15')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024/01/15')).rejects.toThrow('Expected YYYY-MM-DD format');
            });
            it('should reject invalid date format - no separator', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('20240115')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('20240115')).rejects.toThrow('Expected YYYY-MM-DD format');
            });
            it('should reject invalid date format - single digit month/day', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-1-15')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-5')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-1-5')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject invalid date format - extra characters', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15T00:00:00')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15 ')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(' 2024-01-15')).rejects.toThrow(errors_1.ValidationError);
            });
        });
        describe('Non-Existent Date Validation', () => {
            it('should reject February 30th', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-30')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-30')).rejects.toThrow('Date does not exist');
            });
            it('should reject February 29th in non-leap year', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-29')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-29')).rejects.toThrow('Date does not exist');
            });
            it('should accept February 29th in leap year', async () => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-29')).resolves.not.toThrow();
            });
            it('should reject invalid month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-13-01')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-00-01')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject invalid day', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-32')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-00')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject April 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-04-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject June 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-06-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject September 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-09-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject November 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-11-31')).rejects.toThrow(errors_1.ValidationError);
            });
        });
        describe('Date Range Validation', () => {
            it('should reject dates before 1970-01-01', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1969-12-31')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1969-12-31')).rejects.toThrow('Must be on or after 1970-01-01');
            });
            it('should accept 1970-01-01', async () => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1970-01-01')).resolves.not.toThrow();
            });
            it('should reject dates more than 1 day in the future', async () => {
                const futureDate = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);
                const futureDateStr = futureDate.toISOString().split('T')[0];
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(futureDateStr)).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(futureDateStr)).rejects.toThrow('Must be within 1 day of current date');
            });
            it('should accept today\'s date', async () => {
                const today = new Date().toISOString().split('T')[0];
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(today)).resolves.not.toThrow();
            });
            it('should accept tomorrow\'s date (within 1 day)', async () => {
                const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);
                const tomorrowStr = tomorrow.toISOString().split('T')[0];
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(tomorrowStr)).resolves.not.toThrow();
            });
        });
        describe('Valid Date Acceptance', () => {
            beforeEach(() => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
            });
            it('should accept valid date format', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-12-31')).resolves.not.toThrow();
            });
            it('should accept first day of month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-01')).resolves.not.toThrow();
            });
            it('should accept last day of 31-day month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-31')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-03-31')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-05-31')).resolves.not.toThrow();
            });
            it('should accept last day of 30-day month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-04-30')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-06-30')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-09-30')).resolves.not.toThrow();
            });
            it('should accept February 28th', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-28')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-28')).resolves.not.toThrow();
            });
        });
    });
    describe('Error Handling', () => {
        it('should retry on network errors', async () => {
            const networkError = new Error('ECONNRESET');
            networkError.code = 'ECONNRESET';
            mockAxios.get
                .mockRejectedValueOnce(networkError)
                .mockRejectedValueOnce(networkError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(3);
        });
        it('should retry on timeout errors', async () => {
            const timeoutError = new Error('timeout of 30000ms exceeded');
            timeoutError.code = 'ECONNABORTED';
            mockAxios.get
                .mockRejectedValueOnce(timeoutError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should retry on 5xx errors', async () => {
            const serverError = {
                response: {
                    status: 503,
                    statusText: 'Service Unavailable',
                    data: 'Service Unavailable',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get
                .mockRejectedValueOnce(serverError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should retry on 429 rate limit errors', async () => {
            const rateLimitError = {
                response: {
                    status: 429,
                    statusText: 'Too Many Requests',
                    data: 'Rate limit exceeded',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get
                .mockRejectedValueOnce(rateLimitError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should not retry on 404 errors', async () => {
            const notFoundError = {
                response: {
                    status: 404,
                    statusText: 'Not Found',
                    data: 'Page not found',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get.mockRejectedValue(notFoundError);
            await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).rejects.toThrow(errors_1.ValidationError);
            expect(mockAxios.get).toHaveBeenCalledTimes(1);
        });
        it('should fail after max retries', async () => {
            const networkError = new Error('ECONNRESET');
            networkError.code = 'ECONNRESET';
            mockAxios.get.mockRejectedValue(networkError);
            await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).rejects.toThrow();
            expect(mockAxios.get).toHaveBeenCalledTimes(4); // 1 initial + 3 retries
        });
    });
    describe('URL Construction', () => {
        it('should construct correct TDnet URL', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('I_list_001_2024-01-15.html'), expect.any(Object));
        });
        it('should use custom base URL from environment variable', async () => {
            const originalEnv = process.env.TDNET_BASE_URL;
            process.env.TDNET_BASE_URL = 'https://custom.tdnet.url';
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('https://custom.tdnet.url'), expect.any(Object));
            // Restore original environment
            if (originalEnv) {
                process.env.TDNET_BASE_URL = originalEnv;
            }
            else {
                delete process.env.TDNET_BASE_URL;
            }
        });
    });
    describe('HTTP Headers', () => {
        it('should include proper User-Agent header', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                headers: expect.objectContaining({
                    'User-Agent': expect.stringContaining('TDnet-Data-Collector'),
                }),
            }));
        });
        it('should include Accept and Accept-Language headers', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                headers: expect.objectContaining({
                    'Accept': expect.stringContaining('text/html'),
                    'Accept-Language': expect.stringContaining('ja'),
                }),
            }));
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aTE5OFxcaW52ZXN0bWVudF9hbmFseXNpc19vcG9wb1xcc3JjXFxsYW1iZGFcXGNvbGxlY3RvclxcX190ZXN0c19fXFxzY3JhcGUtdGRuZXQtbGlzdC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7OztBQVFILG9CQUFvQjtBQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFUekMsa0RBQTBCO0FBQzFCLDREQUF1RDtBQUN2RCw4REFBbUU7QUFDbkUsOERBQTBEO0FBQzFELDRDQUFrRDtBQU9sRCxNQUFNLFNBQVMsR0FBRyxlQUFrQyxDQUFDO0FBQ3JELE1BQU0sdUJBQXVCLEdBQUcsaUNBQXNFLENBQUM7QUFDdkcsTUFBTSxlQUFlLEdBQUcsMEJBQW1ELENBQUM7QUFFNUUsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUMvQixJQUFJLHVCQUFpRCxDQUFDO0lBRXRELFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFckIsNEJBQTRCO1FBQzVCLHVCQUF1QixHQUFHO1lBQ3hCLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDO1lBQ3BELEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2hCLGFBQWEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQztZQUM5QyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQztTQUM3QyxDQUFDO1FBRVQsZUFBZSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDcEUsQ0FB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QUFDO2lCQUM5RCxDQUFDO2FBQ0gsQ0FBQyxDQUNILENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxtREFBbUQsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNqRSxTQUFTLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDO2dCQUM5QixJQUFJLEVBQUUsZUFBZTtnQkFDckIsTUFBTSxFQUFFLEdBQUc7Z0JBQ1gsVUFBVSxFQUFFLElBQUk7Z0JBQ2hCLE9BQU8sRUFBRSxFQUFFO2dCQUNYLE1BQU0sRUFBRSxFQUFTO2FBQ2xCLENBQUMsQ0FBQztZQUNILHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUU1QyxNQUFNLElBQUEsbUNBQWUsRUFBQyxZQUFZLENBQUMsQ0FBQztZQUVwQyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixDQUN4QyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUNsQixNQUFNLENBQUMsZ0JBQWdCLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUM7b0JBQy9CLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDO29CQUM5QyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO2lCQUNqRCxDQUFDO2FBQ0gsQ0FBQyxDQUNILENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0aTE5OFxcaW52ZXN0bWVudF9hbmFseXNpc19vcG9wb1xcc3JjXFxsYW1iZGFcXGNvbGxlY3RvclxcX190ZXN0c19fXFxzY3JhcGUtdGRuZXQtbGlzdC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBURG5ldCBMaXN0IFNjcmFwZXIgLSBVbml0IFRlc3RzXHJcbiAqXHJcbiAqIFJlcXVpcmVtZW50czog6KaB5Lu2MS4xLCA5LjFcclxuICovXHJcblxyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgeyBzY3JhcGVUZG5ldExpc3QgfSBmcm9tICcuLi9zY3JhcGUtdGRuZXQtbGlzdCc7XHJcbmltcG9ydCB7IHBhcnNlRGlzY2xvc3VyZUxpc3QgfSBmcm9tICcuLi8uLi8uLi9zY3JhcGVyL2h0bWwtcGFyc2VyJztcclxuaW1wb3J0IHsgUmF0ZUxpbWl0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9yYXRlLWxpbWl0ZXInO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9lcnJvcnMnO1xyXG5cclxuLy8gTW9jayBkZXBlbmRlbmNpZXNcclxuamVzdC5tb2NrKCdheGlvcycpO1xyXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NjcmFwZXIvaHRtbC1wYXJzZXInKTtcclxuamVzdC5tb2NrKCcuLi8uLi8uLi91dGlscy9yYXRlLWxpbWl0ZXInKTtcclxuXHJcbmNvbnN0IG1vY2tBeGlvcyA9IGF4aW9zIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBheGlvcz47XHJcbmNvbnN0IG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0ID0gcGFyc2VEaXNjbG9zdXJlTGlzdCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBwYXJzZURpc2Nsb3N1cmVMaXN0PjtcclxuY29uc3QgTW9ja1JhdGVMaW1pdGVyID0gUmF0ZUxpbWl0ZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgUmF0ZUxpbWl0ZXI+O1xyXG5cclxuZGVzY3JpYmUoJ3NjcmFwZVRkbmV0TGlzdCcsICgpID0+IHtcclxuICBsZXQgbW9ja1JhdGVMaW1pdGVySW5zdGFuY2U6IGplc3QuTW9ja2VkPFJhdGVMaW1pdGVyPjtcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuXHJcbiAgICAvLyBNb2NrIFJhdGVMaW1pdGVyIGluc3RhbmNlXHJcbiAgICBtb2NrUmF0ZUxpbWl0ZXJJbnN0YW5jZSA9IHtcclxuICAgICAgd2FpdElmTmVlZGVkOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKSxcclxuICAgICAgcmVzZXQ6IGplc3QuZm4oKSxcclxuICAgICAgZ2V0TWluRGVsYXlNczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgyMDAwKSxcclxuICAgICAgZ2V0TGFzdFJlcXVlc3RUaW1lOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpLFxyXG4gICAgfSBhcyBhbnk7XHJcblxyXG4gICAgTW9ja1JhdGVMaW1pdGVyLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrUmF0ZUxpbWl0ZXJJbnN0YW5jZSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdTdWNjZXNzIENhc2VzJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgc2NyYXBlIFREbmV0IGxpc3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tIdG1sID0gJzxodG1sPjxib2R5PlRlc3QgSFRNTDwvYm9keT48L2h0bWw+JztcclxuICAgICAgY29uc3QgbW9ja0Rpc2Nsb3N1cmVzID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbXBhbnlfY29kZTogJzEyMzQnLFxyXG4gICAgICAgICAgY29tcGFueV9uYW1lOiAnVGVzdCBDb21wYW55JyxcclxuICAgICAgICAgIGRpc2Nsb3N1cmVfdHlwZTogJ+axuueul+efreS/oScsXHJcbiAgICAgICAgICB0aXRsZTogJ1Rlc3QgRGlzY2xvc3VyZScsXHJcbiAgICAgICAgICBkaXNjbG9zZWRfYXQ6ICcyMDI0LTAxLTE1VDAxOjMwOjAwWicsXHJcbiAgICAgICAgICBwZGZfdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS90ZXN0LnBkZicsXHJcbiAgICAgICAgfSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgIGRhdGE6IG1vY2tIdG1sLFxyXG4gICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKG1vY2tEaXNjbG9zdXJlcyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0Rpc2Nsb3N1cmVzKTtcclxuICAgICAgZXhwZWN0KG1vY2tSYXRlTGltaXRlckluc3RhbmNlLndhaXRJZk5lZWRlZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJzIwMjQtMDEtMTUnKSxcclxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcclxuICAgICAgICAgIGhlYWRlcnM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVERuZXQtRGF0YS1Db2xsZWN0b3InKSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICAgIGV4cGVjdChtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0h0bWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBhcHBseSByYXRlIGxpbWl0aW5nIGJlZm9yZSBlYWNoIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tIdG1sID0gJzxodG1sPjxib2R5PlRlc3QgSFRNTDwvYm9keT48L2h0bWw+JztcclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogbW9ja0h0bWwsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSByYXRlIGxpbWl0ZXIgd2FzIGNhbGxlZFxyXG4gICAgICBleHBlY3QobW9ja1JhdGVMaW1pdGVySW5zdGFuY2Uud2FpdElmTmVlZGVkKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICAgIC8vIFZlcmlmeSBheGlvcy5nZXQgd2FzIGNhbGxlZCBhZnRlciByYXRlIGxpbWl0ZXJcclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnVmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgIGRlc2NyaWJlKCdEYXRlIEZvcm1hdCBWYWxpZGF0aW9uJywgKCkgPT4ge1xyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGRhdGUgZm9ybWF0IC0gc2xhc2ggc2VwYXJhdG9yJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQvMDEvMTUnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC8wMS8xNScpKS5yZWplY3RzLnRvVGhyb3coJ0V4cGVjdGVkIFlZWVktTU0tREQgZm9ybWF0Jyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBkYXRlIGZvcm1hdCAtIG5vIHNlcGFyYXRvcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0MDExNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0MDExNScpKS5yZWplY3RzLnRvVGhyb3coJ0V4cGVjdGVkIFlZWVktTU0tREQgZm9ybWF0Jyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBkYXRlIGZvcm1hdCAtIHNpbmdsZSBkaWdpdCBtb250aC9kYXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0xLTE1JykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTEtNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGRhdGUgZm9ybWF0IC0gZXh0cmEgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1VDAwOjAwOjAwJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUgJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJyAyMDI0LTAxLTE1JykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdOb24tRXhpc3RlbnQgRGF0ZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBGZWJydWFyeSAzMHRoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDItMzAnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMi0zMCcpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGUgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBGZWJydWFyeSAyOXRoIGluIG5vbi1sZWFwIHllYXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyMy0wMi0yOScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDIzLTAyLTI5JykpLnJlamVjdHMudG9UaHJvdygnRGF0ZSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IEZlYnJ1YXJ5IDI5dGggaW4gbGVhcCB5ZWFyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAyLTI5JykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBtb250aCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTEzLTAxJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDAtMDEnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBkYXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0zMicpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTAwJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IEFwcmlsIDMxc3QgKDMwLWRheSBtb250aCknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wNC0zMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBKdW5lIDMxc3QgKDMwLWRheSBtb250aCknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wNi0zMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBTZXB0ZW1iZXIgMzFzdCAoMzAtZGF5IG1vbnRoKScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTA5LTMxJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IE5vdmVtYmVyIDMxc3QgKDMwLWRheSBtb250aCknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0xMS0zMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnRGF0ZSBSYW5nZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBkYXRlcyBiZWZvcmUgMTk3MC0wMS0wMScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcxOTY5LTEyLTMxJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzE5NjktMTItMzEnKSkucmVqZWN0cy50b1Rocm93KCdNdXN0IGJlIG9uIG9yIGFmdGVyIDE5NzAtMDEtMDEnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIGFjY2VwdCAxOTcwLTAxLTAxJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcxOTcwLTAxLTAxJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgZGF0ZXMgbW9yZSB0aGFuIDEgZGF5IGluIHRoZSBmdXR1cmUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnV0dXJlRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAyICogMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgY29uc3QgZnV0dXJlRGF0ZVN0ciA9IGZ1dHVyZURhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoZnV0dXJlRGF0ZVN0cikpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoZnV0dXJlRGF0ZVN0cikpLnJlamVjdHMudG9UaHJvdygnTXVzdCBiZSB3aXRoaW4gMSBkYXkgb2YgY3VycmVudCBkYXRlJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgdG9kYXlcXCdzIGRhdGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuICAgICAgICBcclxuICAgICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCh0b2RheSkpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgdG9tb3Jyb3dcXCdzIGRhdGUgKHdpdGhpbiAxIGRheSknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG9tb3Jyb3cgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgY29uc3QgdG9tb3Jyb3dTdHIgPSB0b21vcnJvdy50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QodG9tb3Jyb3dTdHIpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdWYWxpZCBEYXRlIEFjY2VwdGFuY2UnLCAoKSA9PiB7XHJcbiAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IHZhbGlkIGRhdGUgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTEyLTMxJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgZmlyc3QgZGF5IG9mIG1vbnRoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMDEnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIGFjY2VwdCBsYXN0IGRheSBvZiAzMS1kYXkgbW9udGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0zMScpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDMtMzEnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTA1LTMxJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgbGFzdCBkYXkgb2YgMzAtZGF5IG1vbnRoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDQtMzAnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTA2LTMwJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wOS0zMCcpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IEZlYnJ1YXJ5IDI4dGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMi0yOCcpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjMtMDItMjgnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKCdFQ09OTlJFU0VUJyk7XHJcbiAgICAgIChuZXR3b3JrRXJyb3IgYXMgYW55KS5jb2RlID0gJ0VDT05OUkVTRVQnO1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldFxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV0d29ya0Vycm9yKVxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV0d29ya0Vycm9yKVxyXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHJ5IG9uIHRpbWVvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgMzAwMDBtcyBleGNlZWRlZCcpO1xyXG4gICAgICAodGltZW91dEVycm9yIGFzIGFueSkuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldFxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UodGltZW91dEVycm9yKVxyXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHJ5IG9uIDV4eCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNlcnZlckVycm9yID0ge1xyXG4gICAgICAgIHJlc3BvbnNlOiB7XHJcbiAgICAgICAgICBzdGF0dXM6IDUwMyxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcclxuICAgICAgICAgIGRhdGE6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0F4aW9zRXJyb3I6IHRydWUsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBtb2NrQXhpb3MuZ2V0XHJcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShzZXJ2ZXJFcnJvcilcclxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiA0MjkgcmF0ZSBsaW1pdCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJhdGVMaW1pdEVycm9yID0ge1xyXG4gICAgICAgIHJlc3BvbnNlOiB7XHJcbiAgICAgICAgICBzdGF0dXM6IDQyOSxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdUb28gTWFueSBSZXF1ZXN0cycsXHJcbiAgICAgICAgICBkYXRhOiAnUmF0ZSBsaW1pdCBleGNlZWRlZCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNBeGlvc0Vycm9yOiB0cnVlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldFxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UocmF0ZUxpbWl0RXJyb3IpXHJcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XHJcbiAgICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgIGF3YWl0IHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgbm90IHJldHJ5IG9uIDQwNCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5vdEZvdW5kRXJyb3IgPSB7XHJcbiAgICAgICAgcmVzcG9uc2U6IHtcclxuICAgICAgICAgIHN0YXR1czogNDA0LFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ05vdCBGb3VuZCcsXHJcbiAgICAgICAgICBkYXRhOiAnUGFnZSBub3QgZm91bmQnLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQXhpb3NFcnJvcjogdHJ1ZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1JlamVjdGVkVmFsdWUobm90Rm91bmRFcnJvcik7XHJcblxyXG4gICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1JykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGFmdGVyIG1heCByZXRyaWVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBuZXR3b3JrRXJyb3IgPSBuZXcgRXJyb3IoJ0VDT05OUkVTRVQnKTtcclxuICAgICAgKG5ldHdvcmtFcnJvciBhcyBhbnkpLmNvZGUgPSAnRUNPTk5SRVNFVCc7XHJcblxyXG4gICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldHdvcmtFcnJvcik7XHJcblxyXG4gICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1JykpLnJlamVjdHMudG9UaHJvdygpO1xyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDQpOyAvLyAxIGluaXRpYWwgKyAzIHJldHJpZXNcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnVVJMIENvbnN0cnVjdGlvbicsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgY29uc3RydWN0IGNvcnJlY3QgVERuZXQgVVJMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnSV9saXN0XzAwMV8yMDI0LTAxLTE1Lmh0bWwnKSxcclxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdXNlIGN1c3RvbSBiYXNlIFVSTCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52LlRETkVUX0JBU0VfVVJMO1xyXG4gICAgICBwcm9jZXNzLmVudi5URE5FVF9CQVNFX1VSTCA9ICdodHRwczovL2N1c3RvbS50ZG5ldC51cmwnO1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgIH0pO1xyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2h0dHBzOi8vY3VzdG9tLnRkbmV0LnVybCcpLFxyXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBlbnZpcm9ubWVudFxyXG4gICAgICBpZiAob3JpZ2luYWxFbnYpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5URE5FVF9CQVNFX1VSTCA9IG9yaWdpbmFsRW52O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5URE5FVF9CQVNFX1VSTDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdIVFRQIEhlYWRlcnMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgcHJvcGVyIFVzZXItQWdlbnQgaGVhZGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXHJcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgICAgaGVhZGVyczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdURG5ldC1EYXRhLUNvbGxlY3RvcicpLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBBY2NlcHQgYW5kIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXHJcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgICAgaGVhZGVyczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgICAgICAnQWNjZXB0JzogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3RleHQvaHRtbCcpLFxyXG4gICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2phJyksXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwidmVyc2lvbiI6M30=
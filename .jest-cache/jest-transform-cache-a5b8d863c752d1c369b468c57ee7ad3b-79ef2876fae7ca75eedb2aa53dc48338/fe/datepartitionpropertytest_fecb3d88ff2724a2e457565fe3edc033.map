{"file":"C:\\Users\\ti198\\investment_analysis_opopo\\src\\__tests__\\date-partition.property.test.ts","mappings":"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","names":[],"sources":["C:\\Users\\ti198\\investment_analysis_opopo\\src\\__tests__\\date-partition.property.test.ts"],"sourcesContent":["/**\n * Property-based tests for date_partition generation\n * \n * Tests the correctness of generateDatePartition function using fast-check\n * to verify behavior across a wide range of inputs.\n */\n\nimport * as fc from 'fast-check';\nimport { generateDatePartition } from '../utils/date-partition';\n\ndescribe('generateDatePartition - Property Tests', () => {\n  /**\n   * Property: generateDatePartition always returns YYYY-MM format (JST-based)\n   * \n   * For any valid ISO 8601 date string, the function should return a string\n   * in YYYY-MM format based on JST (UTC+9) timezone.\n   */\n  it('should always return YYYY-MM format for valid ISO 8601 dates', () => {\n    fc.assert(\n      fc.property(\n        // Generate arbitrary dates between 1970-01-01 and current time\n        fc.date({ min: new Date('1970-01-01'), max: new Date() }),\n        (date) => {\n          const isoString = date.toISOString();\n          const result = generateDatePartition(isoString);\n          \n          // Verify format: YYYY-MM\n          expect(result).toMatch(/^\\d{4}-\\d{2}$/);\n          \n          // Verify year is within valid range\n          const [year, month] = result.split('-').map(Number);\n          expect(year).toBeGreaterThanOrEqual(1970);\n          expect(year).toBeLessThanOrEqual(new Date().getFullYear() + 1);\n          \n          // Verify month is valid (01-12)\n          expect(month).toBeGreaterThanOrEqual(1);\n          expect(month).toBeLessThanOrEqual(12);\n        }\n      ),\n      { numRuns: 1000 } // Run 1000 iterations for thorough testing\n    );\n  });\n\n  /**\n   * Property: JST conversion is correctly applied\n   * \n   * Verifies that the function correctly converts UTC to JST (UTC+9)\n   * before extracting the year and month.\n   */\n  it('should correctly convert UTC to JST before extracting year-month', () => {\n    fc.assert(\n      fc.property(\n        fc.date({ min: new Date('1970-01-01'), max: new Date() }),\n        (date) => {\n          const isoString = date.toISOString();\n          const result = generateDatePartition(isoString);\n          \n          // Calculate expected JST date\n          const utcDate = new Date(isoString);\n          const jstDate = new Date(utcDate.getTime() + 9 * 60 * 60 * 1000);\n          const expectedYear = jstDate.getUTCFullYear();\n          const expectedMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');\n          const expected = `${expectedYear}-${expectedMonth}`;\n          \n          expect(result).toBe(expected);\n        }\n      ),\n      { numRuns: 1000 }\n    );\n  });\n\n  /**\n   * Property: Month boundary edge cases\n   * \n   * Tests specific edge cases where UTC to JST conversion crosses month boundaries.\n   */\n  describe('Month boundary edge cases', () => {\n    it('should handle UTC month-end to JST next-month (2024-01-31T15:30:00Z → 2024-02)', () => {\n      // UTC: 2024-01-31 15:30 → JST: 2024-02-01 00:30\n      const result = generateDatePartition('2024-01-31T15:30:00Z');\n      expect(result).toBe('2024-02');\n    });\n\n    it('should handle UTC month-start staying in same month (2024-02-01T15:00:00Z → 2024-02)', () => {\n      // UTC: 2024-02-01 15:00 → JST: 2024-02-02 00:00\n      const result = generateDatePartition('2024-02-01T15:00:00Z');\n      expect(result).toBe('2024-02');\n    });\n\n    it('should handle leap year February (2024-02-29T15:00:00Z → 2024-03)', () => {\n      // UTC: 2024-02-29 15:00 → JST: 2024-03-01 00:00\n      const result = generateDatePartition('2024-02-29T15:00:00Z');\n      expect(result).toBe('2024-03');\n    });\n\n    it('should handle non-leap year February (2023-02-28T15:00:00Z → 2023-03)', () => {\n      // UTC: 2023-02-28 15:00 → JST: 2023-03-01 00:00\n      const result = generateDatePartition('2023-02-28T15:00:00Z');\n      expect(result).toBe('2023-03');\n    });\n\n    it('should handle year boundary (2023-12-31T15:30:00Z → 2024-01)', () => {\n      // UTC: 2023-12-31 15:30 → JST: 2024-01-01 00:30\n      const result = generateDatePartition('2023-12-31T15:30:00Z');\n      expect(result).toBe('2024-01');\n    });\n\n    it('should handle year boundary staying in same year (2024-01-01T15:00:00Z → 2024-01)', () => {\n      // UTC: 2024-01-01 15:00 → JST: 2024-01-02 00:00\n      const result = generateDatePartition('2024-01-01T15:00:00Z');\n      expect(result).toBe('2024-01');\n    });\n\n    it('should handle early morning UTC (2024-01-15T00:30:00Z → 2024-01)', () => {\n      // UTC: 2024-01-15 00:30 → JST: 2024-01-15 09:30\n      const result = generateDatePartition('2024-01-15T00:30:00Z');\n      expect(result).toBe('2024-01');\n    });\n\n    it('should handle late evening UTC crossing to next day JST (2024-01-15T16:00:00Z → 2024-01)', () => {\n      // UTC: 2024-01-15 16:00 → JST: 2024-01-16 01:00\n      const result = generateDatePartition('2024-01-15T16:00:00Z');\n      expect(result).toBe('2024-01');\n    });\n  });\n\n  /**\n   * Property: All months are correctly handled\n   * \n   * Verifies that all 12 months are correctly processed.\n   */\n  it('should correctly handle all 12 months', () => {\n    fc.assert(\n      fc.property(\n        fc.integer({ min: 2020, max: 2025 }), // year (recent years)\n        fc.integer({ min: 1, max: 12 }), // month\n        fc.integer({ min: 1, max: 28 }), // day (safe for all months)\n        fc.integer({ min: 0, max: 14 }), // hour (0-14 to avoid future dates)\n        fc.integer({ min: 0, max: 59 }), // minute\n        (year, month, day, hour, minute) => {\n          const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00Z`;\n          \n          // Skip if date is in the future\n          if (new Date(dateStr) > new Date()) {\n            return true;\n          }\n          \n          const result = generateDatePartition(dateStr);\n          \n          // Verify format\n          expect(result).toMatch(/^\\d{4}-\\d{2}$/);\n          \n          // Verify the result is a valid year-month\n          const [resultYear, resultMonth] = result.split('-').map(Number);\n          expect(resultYear).toBeGreaterThanOrEqual(2020);\n          expect(resultYear).toBeLessThanOrEqual(2026);\n          expect(resultMonth).toBeGreaterThanOrEqual(1);\n          expect(resultMonth).toBeLessThanOrEqual(12);\n          \n          return true;\n        }\n      ),\n      { numRuns: 1000 }\n    );\n  });\n\n  /**\n   * Property: Idempotency\n   * \n   * Calling generateDatePartition multiple times with the same input\n   * should always return the same result.\n   */\n  it('should be idempotent (same input always produces same output)', () => {\n    fc.assert(\n      fc.property(\n        fc.date({ min: new Date('1970-01-01'), max: new Date() }),\n        (date) => {\n          const isoString = date.toISOString();\n          const result1 = generateDatePartition(isoString);\n          const result2 = generateDatePartition(isoString);\n          const result3 = generateDatePartition(isoString);\n          \n          expect(result1).toBe(result2);\n          expect(result2).toBe(result3);\n        }\n      ),\n      { numRuns: 1000 }\n    );\n  });\n\n  /**\n   * Property: Consistency with manual calculation\n   * \n   * The result should match a manual calculation of JST year-month.\n   */\n  it('should match manual JST year-month calculation', () => {\n    fc.assert(\n      fc.property(\n        fc.date({ min: new Date('1970-01-01'), max: new Date() }),\n        (date) => {\n          const isoString = date.toISOString();\n          const result = generateDatePartition(isoString);\n          \n          // Manual calculation\n          const utcDate = new Date(isoString);\n          const jstTimestamp = utcDate.getTime() + 9 * 60 * 60 * 1000;\n          const jstDate = new Date(jstTimestamp);\n          const manualYear = jstDate.getUTCFullYear();\n          const manualMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');\n          const manualResult = `${manualYear}-${manualMonth}`;\n          \n          expect(result).toBe(manualResult);\n        }\n      ),\n      { numRuns: 1000 }\n    );\n  });\n\n  /**\n   * Property: Timezone offset handling\n   * \n   * Tests that dates with explicit timezone offsets are correctly handled.\n   */\n  it('should handle dates with explicit timezone offsets', () => {\n    // Test with +09:00 offset (JST)\n    const jstDate = '2024-01-15T10:30:00+09:00';\n    const result1 = generateDatePartition(jstDate);\n    expect(result1).toBe('2024-01');\n\n    // Test with -05:00 offset (EST)\n    const estDate = '2024-01-15T10:30:00-05:00';\n    const result2 = generateDatePartition(estDate);\n    // EST 10:30 = UTC 15:30 = JST 00:30 (next day)\n    expect(result2).toBe('2024-01');\n\n    // Test with +00:00 offset (UTC)\n    const utcDate = '2024-01-15T10:30:00+00:00';\n    const result3 = generateDatePartition(utcDate);\n    expect(result3).toBe('2024-01');\n  });\n\n  /**\n   * Property: Milliseconds precision\n   * \n   * Tests that dates with milliseconds are correctly handled.\n   */\n  it('should handle dates with milliseconds precision', () => {\n    fc.assert(\n      fc.property(\n        fc.date({ min: new Date('1970-01-01'), max: new Date() }),\n        fc.integer({ min: 0, max: 999 }), // milliseconds\n        (date, ms) => {\n          // Create ISO string with milliseconds\n          const baseIso = date.toISOString();\n          const isoWithMs = baseIso.replace(/\\.\\d{3}Z$/, `.${String(ms).padStart(3, '0')}Z`);\n          \n          const result = generateDatePartition(isoWithMs);\n          \n          // Verify format\n          expect(result).toMatch(/^\\d{4}-\\d{2}$/);\n          \n          // Milliseconds should not affect the year-month result\n          const resultWithoutMs = generateDatePartition(baseIso);\n          expect(result).toBe(resultWithoutMs);\n        }\n      ),\n      { numRuns: 1000 }\n    );\n  });\n\n  /**\n   * Property: Deterministic output for same UTC timestamp\n   * \n   * Different representations of the same UTC timestamp should produce\n   * the same date_partition.\n   */\n  it('should produce same result for equivalent UTC timestamps', () => {\n    // Same moment in time, different representations\n    const utcZ = '2024-01-15T10:30:00Z';\n    const utcOffset = '2024-01-15T10:30:00+00:00';\n    const jstOffset = '2024-01-15T19:30:00+09:00';\n    \n    const result1 = generateDatePartition(utcZ);\n    const result2 = generateDatePartition(utcOffset);\n    const result3 = generateDatePartition(jstOffset);\n    \n    expect(result1).toBe(result2);\n    expect(result2).toBe(result3);\n    expect(result1).toBe('2024-01');\n  });\n\n  /**\n   * Property: Handles all valid hours (0-23)\n   * \n   * Verifies correct behavior across all hours of the day.\n   */\n  it('should correctly handle all hours of the day', () => {\n    fc.assert(\n      fc.property(\n        fc.integer({ min: 0, max: 23 }), // hour\n        (hour) => {\n          const dateStr = `2024-01-15T${String(hour).padStart(2, '0')}:30:00Z`;\n          const result = generateDatePartition(dateStr);\n          \n          // Calculate expected result\n          const utcDate = new Date(dateStr);\n          const jstDate = new Date(utcDate.getTime() + 9 * 60 * 60 * 1000);\n          const expectedMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');\n          const expectedYear = jstDate.getUTCFullYear();\n          \n          expect(result).toBe(`${expectedYear}-${expectedMonth}`);\n        }\n      ),\n      { numRuns: 24 } // Test all 24 hours\n    );\n  });\n});\n"],"version":3}
543f899cc77cbd3b91ece317ebb6b5c2
"use strict";
/**
 * Property-based tests for date_partition generation
 *
 * Tests the correctness of generateDatePartition function using fast-check
 * to verify behavior across a wide range of inputs.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const fc = __importStar(require("fast-check"));
const date_partition_1 = require("../utils/date-partition");
describe('generateDatePartition - Property Tests', () => {
    /**
     * Property: generateDatePartition always returns YYYY-MM format (JST-based)
     *
     * For any valid ISO 8601 date string, the function should return a string
     * in YYYY-MM format based on JST (UTC+9) timezone.
     */
    it('should always return YYYY-MM format for valid ISO 8601 dates', () => {
        fc.assert(fc.property(
        // Generate arbitrary dates between 1970-01-01 and current time
        fc.date({ min: new Date('1970-01-01'), max: new Date() }), (date) => {
            const isoString = date.toISOString();
            const result = (0, date_partition_1.generateDatePartition)(isoString);
            // Verify format: YYYY-MM
            expect(result).toMatch(/^\d{4}-\d{2}$/);
            // Verify year is within valid range
            const [year, month] = result.split('-').map(Number);
            expect(year).toBeGreaterThanOrEqual(1970);
            expect(year).toBeLessThanOrEqual(new Date().getFullYear() + 1);
            // Verify month is valid (01-12)
            expect(month).toBeGreaterThanOrEqual(1);
            expect(month).toBeLessThanOrEqual(12);
        }), { numRuns: 1000 } // Run 1000 iterations for thorough testing
        );
    });
    /**
     * Property: JST conversion is correctly applied
     *
     * Verifies that the function correctly converts UTC to JST (UTC+9)
     * before extracting the year and month.
     */
    it('should correctly convert UTC to JST before extracting year-month', () => {
        fc.assert(fc.property(fc.date({ min: new Date('1970-01-01'), max: new Date() }), (date) => {
            const isoString = date.toISOString();
            const result = (0, date_partition_1.generateDatePartition)(isoString);
            // Calculate expected JST date
            const utcDate = new Date(isoString);
            const jstDate = new Date(utcDate.getTime() + 9 * 60 * 60 * 1000);
            const expectedYear = jstDate.getUTCFullYear();
            const expectedMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');
            const expected = `${expectedYear}-${expectedMonth}`;
            expect(result).toBe(expected);
        }), { numRuns: 1000 });
    });
    /**
     * Property: Month boundary edge cases
     *
     * Tests specific edge cases where UTC to JST conversion crosses month boundaries.
     */
    describe('Month boundary edge cases', () => {
        it('should handle UTC month-end to JST next-month (2024-01-31T15:30:00Z → 2024-02)', () => {
            // UTC: 2024-01-31 15:30 → JST: 2024-02-01 00:30
            const result = (0, date_partition_1.generateDatePartition)('2024-01-31T15:30:00Z');
            expect(result).toBe('2024-02');
        });
        it('should handle UTC month-start staying in same month (2024-02-01T15:00:00Z → 2024-02)', () => {
            // UTC: 2024-02-01 15:00 → JST: 2024-02-02 00:00
            const result = (0, date_partition_1.generateDatePartition)('2024-02-01T15:00:00Z');
            expect(result).toBe('2024-02');
        });
        it('should handle leap year February (2024-02-29T15:00:00Z → 2024-03)', () => {
            // UTC: 2024-02-29 15:00 → JST: 2024-03-01 00:00
            const result = (0, date_partition_1.generateDatePartition)('2024-02-29T15:00:00Z');
            expect(result).toBe('2024-03');
        });
        it('should handle non-leap year February (2023-02-28T15:00:00Z → 2023-03)', () => {
            // UTC: 2023-02-28 15:00 → JST: 2023-03-01 00:00
            const result = (0, date_partition_1.generateDatePartition)('2023-02-28T15:00:00Z');
            expect(result).toBe('2023-03');
        });
        it('should handle year boundary (2023-12-31T15:30:00Z → 2024-01)', () => {
            // UTC: 2023-12-31 15:30 → JST: 2024-01-01 00:30
            const result = (0, date_partition_1.generateDatePartition)('2023-12-31T15:30:00Z');
            expect(result).toBe('2024-01');
        });
        it('should handle year boundary staying in same year (2024-01-01T15:00:00Z → 2024-01)', () => {
            // UTC: 2024-01-01 15:00 → JST: 2024-01-02 00:00
            const result = (0, date_partition_1.generateDatePartition)('2024-01-01T15:00:00Z');
            expect(result).toBe('2024-01');
        });
        it('should handle early morning UTC (2024-01-15T00:30:00Z → 2024-01)', () => {
            // UTC: 2024-01-15 00:30 → JST: 2024-01-15 09:30
            const result = (0, date_partition_1.generateDatePartition)('2024-01-15T00:30:00Z');
            expect(result).toBe('2024-01');
        });
        it('should handle late evening UTC crossing to next day JST (2024-01-15T16:00:00Z → 2024-01)', () => {
            // UTC: 2024-01-15 16:00 → JST: 2024-01-16 01:00
            const result = (0, date_partition_1.generateDatePartition)('2024-01-15T16:00:00Z');
            expect(result).toBe('2024-01');
        });
    });
    /**
     * Property: All months are correctly handled
     *
     * Verifies that all 12 months are correctly processed.
     */
    it('should correctly handle all 12 months', () => {
        fc.assert(fc.property(fc.integer({ min: 2020, max: 2025 }), // year (recent years)
        fc.integer({ min: 1, max: 12 }), // month
        fc.integer({ min: 1, max: 28 }), // day (safe for all months)
        fc.integer({ min: 0, max: 14 }), // hour (0-14 to avoid future dates)
        fc.integer({ min: 0, max: 59 }), // minute
        (year, month, day, hour, minute) => {
            const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00Z`;
            // Skip if date is in the future
            if (new Date(dateStr) > new Date()) {
                return true;
            }
            const result = (0, date_partition_1.generateDatePartition)(dateStr);
            // Verify format
            expect(result).toMatch(/^\d{4}-\d{2}$/);
            // Verify the result is a valid year-month
            const [resultYear, resultMonth] = result.split('-').map(Number);
            expect(resultYear).toBeGreaterThanOrEqual(2020);
            expect(resultYear).toBeLessThanOrEqual(2026);
            expect(resultMonth).toBeGreaterThanOrEqual(1);
            expect(resultMonth).toBeLessThanOrEqual(12);
            return true;
        }), { numRuns: 1000 });
    });
    /**
     * Property: Idempotency
     *
     * Calling generateDatePartition multiple times with the same input
     * should always return the same result.
     */
    it('should be idempotent (same input always produces same output)', () => {
        fc.assert(fc.property(fc.date({ min: new Date('1970-01-01'), max: new Date() }), (date) => {
            const isoString = date.toISOString();
            const result1 = (0, date_partition_1.generateDatePartition)(isoString);
            const result2 = (0, date_partition_1.generateDatePartition)(isoString);
            const result3 = (0, date_partition_1.generateDatePartition)(isoString);
            expect(result1).toBe(result2);
            expect(result2).toBe(result3);
        }), { numRuns: 1000 });
    });
    /**
     * Property: Consistency with manual calculation
     *
     * The result should match a manual calculation of JST year-month.
     */
    it('should match manual JST year-month calculation', () => {
        fc.assert(fc.property(fc.date({ min: new Date('1970-01-01'), max: new Date() }), (date) => {
            const isoString = date.toISOString();
            const result = (0, date_partition_1.generateDatePartition)(isoString);
            // Manual calculation
            const utcDate = new Date(isoString);
            const jstTimestamp = utcDate.getTime() + 9 * 60 * 60 * 1000;
            const jstDate = new Date(jstTimestamp);
            const manualYear = jstDate.getUTCFullYear();
            const manualMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');
            const manualResult = `${manualYear}-${manualMonth}`;
            expect(result).toBe(manualResult);
        }), { numRuns: 1000 });
    });
    /**
     * Property: Timezone offset handling
     *
     * Tests that dates with explicit timezone offsets are correctly handled.
     */
    it('should handle dates with explicit timezone offsets', () => {
        // Test with +09:00 offset (JST)
        const jstDate = '2024-01-15T10:30:00+09:00';
        const result1 = (0, date_partition_1.generateDatePartition)(jstDate);
        expect(result1).toBe('2024-01');
        // Test with -05:00 offset (EST)
        const estDate = '2024-01-15T10:30:00-05:00';
        const result2 = (0, date_partition_1.generateDatePartition)(estDate);
        // EST 10:30 = UTC 15:30 = JST 00:30 (next day)
        expect(result2).toBe('2024-01');
        // Test with +00:00 offset (UTC)
        const utcDate = '2024-01-15T10:30:00+00:00';
        const result3 = (0, date_partition_1.generateDatePartition)(utcDate);
        expect(result3).toBe('2024-01');
    });
    /**
     * Property: Milliseconds precision
     *
     * Tests that dates with milliseconds are correctly handled.
     */
    it('should handle dates with milliseconds precision', () => {
        fc.assert(fc.property(fc.date({ min: new Date('1970-01-01'), max: new Date() }), fc.integer({ min: 0, max: 999 }), // milliseconds
        (date, ms) => {
            // Create ISO string with milliseconds
            const baseIso = date.toISOString();
            const isoWithMs = baseIso.replace(/\.\d{3}Z$/, `.${String(ms).padStart(3, '0')}Z`);
            const result = (0, date_partition_1.generateDatePartition)(isoWithMs);
            // Verify format
            expect(result).toMatch(/^\d{4}-\d{2}$/);
            // Milliseconds should not affect the year-month result
            const resultWithoutMs = (0, date_partition_1.generateDatePartition)(baseIso);
            expect(result).toBe(resultWithoutMs);
        }), { numRuns: 1000 });
    });
    /**
     * Property: Deterministic output for same UTC timestamp
     *
     * Different representations of the same UTC timestamp should produce
     * the same date_partition.
     */
    it('should produce same result for equivalent UTC timestamps', () => {
        // Same moment in time, different representations
        const utcZ = '2024-01-15T10:30:00Z';
        const utcOffset = '2024-01-15T10:30:00+00:00';
        const jstOffset = '2024-01-15T19:30:00+09:00';
        const result1 = (0, date_partition_1.generateDatePartition)(utcZ);
        const result2 = (0, date_partition_1.generateDatePartition)(utcOffset);
        const result3 = (0, date_partition_1.generateDatePartition)(jstOffset);
        expect(result1).toBe(result2);
        expect(result2).toBe(result3);
        expect(result1).toBe('2024-01');
    });
    /**
     * Property: Handles all valid hours (0-23)
     *
     * Verifies correct behavior across all hours of the day.
     */
    it('should correctly handle all hours of the day', () => {
        fc.assert(fc.property(fc.integer({ min: 0, max: 23 }), // hour
        (hour) => {
            const dateStr = `2024-01-15T${String(hour).padStart(2, '0')}:30:00Z`;
            const result = (0, date_partition_1.generateDatePartition)(dateStr);
            // Calculate expected result
            const utcDate = new Date(dateStr);
            const jstDate = new Date(utcDate.getTime() + 9 * 60 * 60 * 1000);
            const expectedMonth = String(jstDate.getUTCMonth() + 1).padStart(2, '0');
            const expectedYear = jstDate.getUTCFullYear();
            expect(result).toBe(`${expectedYear}-${expectedMonth}`);
        }), { numRuns: 24 } // Test all 24 hours
        );
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aTE5OFxcaW52ZXN0bWVudF9hbmFseXNpc19vcG9wb1xcc3JjXFxfX3Rlc3RzX19cXGRhdGUtcGFydGl0aW9uLnByb3BlcnR5LnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILCtDQUFpQztBQUNqQyw0REFBZ0U7QUFFaEUsUUFBUSxDQUFDLHdDQUF3QyxFQUFFLEdBQUcsRUFBRTtJQUN0RDs7Ozs7T0FLRztJQUNILEVBQUUsQ0FBQyw4REFBOEQsRUFBRSxHQUFHLEVBQUU7UUFDdEUsRUFBRSxDQUFDLE1BQU0sQ0FDUCxFQUFFLENBQUMsUUFBUTtRQUNULCtEQUErRDtRQUMvRCxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksRUFBRSxFQUFFLENBQUMsRUFDekQsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNQLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNyQyxNQUFNLE1BQU0sR0FBRyxJQUFBLHNDQUFxQixFQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRWhELHlCQUF5QjtZQUN6QixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRXhDLG9DQUFvQztZQUNwQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsbUJBQW1CLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUUv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QUFNLFlBQVksR0FBRyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7WUFFOUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksSUFBSSxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBQzFELENBQUMsQ0FDRixFQUNELEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDLG9CQUFvQjtTQUNyQyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRpMTk4XFxpbnZlc3RtZW50X2FuYWx5c2lzX29wb3BvXFxzcmNcXF9fdGVzdHNfX1xcZGF0ZS1wYXJ0aXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3BlcnR5LWJhc2VkIHRlc3RzIGZvciBkYXRlX3BhcnRpdGlvbiBnZW5lcmF0aW9uXG4gKiBcbiAqIFRlc3RzIHRoZSBjb3JyZWN0bmVzcyBvZiBnZW5lcmF0ZURhdGVQYXJ0aXRpb24gZnVuY3Rpb24gdXNpbmcgZmFzdC1jaGVja1xuICogdG8gdmVyaWZ5IGJlaGF2aW9yIGFjcm9zcyBhIHdpZGUgcmFuZ2Ugb2YgaW5wdXRzLlxuICovXG5cbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0IHsgZ2VuZXJhdGVEYXRlUGFydGl0aW9uIH0gZnJvbSAnLi4vdXRpbHMvZGF0ZS1wYXJ0aXRpb24nO1xuXG5kZXNjcmliZSgnZ2VuZXJhdGVEYXRlUGFydGl0aW9uIC0gUHJvcGVydHkgVGVzdHMnLCAoKSA9PiB7XG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogZ2VuZXJhdGVEYXRlUGFydGl0aW9uIGFsd2F5cyByZXR1cm5zIFlZWVktTU0gZm9ybWF0IChKU1QtYmFzZWQpXG4gICAqIFxuICAgKiBGb3IgYW55IHZhbGlkIElTTyA4NjAxIGRhdGUgc3RyaW5nLCB0aGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHN0cmluZ1xuICAgKiBpbiBZWVlZLU1NIGZvcm1hdCBiYXNlZCBvbiBKU1QgKFVUQys5KSB0aW1lem9uZS5cbiAgICovXG4gIGl0KCdzaG91bGQgYWx3YXlzIHJldHVybiBZWVlZLU1NIGZvcm1hdCBmb3IgdmFsaWQgSVNPIDg2MDEgZGF0ZXMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIC8vIEdlbmVyYXRlIGFyYml0cmFyeSBkYXRlcyBiZXR3ZWVuIDE5NzAtMDEtMDEgYW5kIGN1cnJlbnQgdGltZVxuICAgICAgICBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCkgfSksXG4gICAgICAgIChkYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNvU3RyaW5nID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbihpc29TdHJpbmcpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZlcmlmeSBmb3JtYXQ6IFlZWVktTU1cbiAgICAgICAgICBleHBlY3QocmVzdWx0KS50b01hdGNoKC9eXFxkezR9LVxcZHsyfSQvKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgeWVhciBpcyB3aXRoaW4gdmFsaWQgcmFuZ2VcbiAgICAgICAgICBjb25zdCBbeWVhciwgbW9udGhdID0gcmVzdWx0LnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gICAgICAgICAgZXhwZWN0KHllYXIpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMTk3MCk7XG4gICAgICAgICAgZXhwZWN0KHllYXIpLnRvQmVMZXNzVGhhbk9yRXF1YWwobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICsgMSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IG1vbnRoIGlzIHZhbGlkICgwMS0xMilcbiAgICAgICAgICBleHBlY3QobW9udGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMSk7XG4gICAgICAgICAgZXhwZWN0KG1vbnRoKS50b0JlTGVzc1RoYW5PckVxdWFsKDEyKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwMCB9IC8vIFJ1biAxMDAwIGl0ZXJhdGlvbnMgZm9yIHRob3JvdWdoIHRlc3RpbmdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogUHJvcGVydHk6IEpTVCBjb252ZXJzaW9uIGlzIGNvcnJlY3RseSBhcHBsaWVkXG4gICAqIFxuICAgKiBWZXJpZmllcyB0aGF0IHRoZSBmdW5jdGlvbiBjb3JyZWN0bHkgY29udmVydHMgVVRDIHRvIEpTVCAoVVRDKzkpXG4gICAqIGJlZm9yZSBleHRyYWN0aW5nIHRoZSB5ZWFyIGFuZCBtb250aC5cbiAgICovXG4gIGl0KCdzaG91bGQgY29ycmVjdGx5IGNvbnZlcnQgVVRDIHRvIEpTVCBiZWZvcmUgZXh0cmFjdGluZyB5ZWFyLW1vbnRoJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCkgfSksXG4gICAgICAgIChkYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNvU3RyaW5nID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbihpc29TdHJpbmcpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBleHBlY3RlZCBKU1QgZGF0ZVxuICAgICAgICAgIGNvbnN0IHV0Y0RhdGUgPSBuZXcgRGF0ZShpc29TdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IGpzdERhdGUgPSBuZXcgRGF0ZSh1dGNEYXRlLmdldFRpbWUoKSArIDkgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRZZWFyID0ganN0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkTW9udGggPSBTdHJpbmcoanN0RGF0ZS5nZXRVVENNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IGAke2V4cGVjdGVkWWVhcn0tJHtleHBlY3RlZE1vbnRofWA7XG4gICAgICAgICAgXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShleHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogTW9udGggYm91bmRhcnkgZWRnZSBjYXNlc1xuICAgKiBcbiAgICogVGVzdHMgc3BlY2lmaWMgZWRnZSBjYXNlcyB3aGVyZSBVVEMgdG8gSlNUIGNvbnZlcnNpb24gY3Jvc3NlcyBtb250aCBib3VuZGFyaWVzLlxuICAgKi9cbiAgZGVzY3JpYmUoJ01vbnRoIGJvdW5kYXJ5IGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgVVRDIG1vbnRoLWVuZCB0byBKU1QgbmV4dC1tb250aCAoMjAyNC0wMS0zMVQxNTozMDowMFog4oaSIDIwMjQtMDIpJywgKCkgPT4ge1xuICAgICAgLy8gVVRDOiAyMDI0LTAxLTMxIDE1OjMwIOKGkiBKU1Q6IDIwMjQtMDItMDEgMDA6MzBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbignMjAyNC0wMS0zMVQxNTozMDowMFonKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJzIwMjQtMDInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIFVUQyBtb250aC1zdGFydCBzdGF5aW5nIGluIHNhbWUgbW9udGggKDIwMjQtMDItMDFUMTU6MDA6MDBaIOKGkiAyMDI0LTAyKScsICgpID0+IHtcbiAgICAgIC8vIFVUQzogMjAyNC0wMi0wMSAxNTowMCDihpIgSlNUOiAyMDI0LTAyLTAyIDAwOjAwXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oJzIwMjQtMDItMDFUMTU6MDA6MDBaJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCcyMDI0LTAyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsZWFwIHllYXIgRmVicnVhcnkgKDIwMjQtMDItMjlUMTU6MDA6MDBaIOKGkiAyMDI0LTAzKScsICgpID0+IHtcbiAgICAgIC8vIFVUQzogMjAyNC0wMi0yOSAxNTowMCDihpIgSlNUOiAyMDI0LTAzLTAxIDAwOjAwXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oJzIwMjQtMDItMjlUMTU6MDA6MDBaJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCcyMDI0LTAzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBub24tbGVhcCB5ZWFyIEZlYnJ1YXJ5ICgyMDIzLTAyLTI4VDE1OjAwOjAwWiDihpIgMjAyMy0wMyknLCAoKSA9PiB7XG4gICAgICAvLyBVVEM6IDIwMjMtMDItMjggMTU6MDAg4oaSIEpTVDogMjAyMy0wMy0wMSAwMDowMFxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKCcyMDIzLTAyLTI4VDE1OjAwOjAwWicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnMjAyMy0wMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgeWVhciBib3VuZGFyeSAoMjAyMy0xMi0zMVQxNTozMDowMFog4oaSIDIwMjQtMDEpJywgKCkgPT4ge1xuICAgICAgLy8gVVRDOiAyMDIzLTEyLTMxIDE1OjMwIOKGkiBKU1Q6IDIwMjQtMDEtMDEgMDA6MzBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbignMjAyMy0xMi0zMVQxNTozMDowMFonKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJzIwMjQtMDEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHllYXIgYm91bmRhcnkgc3RheWluZyBpbiBzYW1lIHllYXIgKDIwMjQtMDEtMDFUMTU6MDA6MDBaIOKGkiAyMDI0LTAxKScsICgpID0+IHtcbiAgICAgIC8vIFVUQzogMjAyNC0wMS0wMSAxNTowMCDihpIgSlNUOiAyMDI0LTAxLTAyIDAwOjAwXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oJzIwMjQtMDEtMDFUMTU6MDA6MDBaJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCcyMDI0LTAxJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlYXJseSBtb3JuaW5nIFVUQyAoMjAyNC0wMS0xNVQwMDozMDowMFog4oaSIDIwMjQtMDEpJywgKCkgPT4ge1xuICAgICAgLy8gVVRDOiAyMDI0LTAxLTE1IDAwOjMwIOKGkiBKU1Q6IDIwMjQtMDEtMTUgMDk6MzBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbignMjAyNC0wMS0xNVQwMDozMDowMFonKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJzIwMjQtMDEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhdGUgZXZlbmluZyBVVEMgY3Jvc3NpbmcgdG8gbmV4dCBkYXkgSlNUICgyMDI0LTAxLTE1VDE2OjAwOjAwWiDihpIgMjAyNC0wMSknLCAoKSA9PiB7XG4gICAgICAvLyBVVEM6IDIwMjQtMDEtMTUgMTY6MDAg4oaSIEpTVDogMjAyNC0wMS0xNiAwMTowMFxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKCcyMDI0LTAxLTE1VDE2OjAwOjAwWicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnMjAyNC0wMScpO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogUHJvcGVydHk6IEFsbCBtb250aHMgYXJlIGNvcnJlY3RseSBoYW5kbGVkXG4gICAqIFxuICAgKiBWZXJpZmllcyB0aGF0IGFsbCAxMiBtb250aHMgYXJlIGNvcnJlY3RseSBwcm9jZXNzZWQuXG4gICAqL1xuICBpdCgnc2hvdWxkIGNvcnJlY3RseSBoYW5kbGUgYWxsIDEyIG1vbnRocycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMjAyMCwgbWF4OiAyMDI1IH0pLCAvLyB5ZWFyIChyZWNlbnQgeWVhcnMpXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTIgfSksIC8vIG1vbnRoXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMjggfSksIC8vIGRheSAoc2FmZSBmb3IgYWxsIG1vbnRocylcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxNCB9KSwgLy8gaG91ciAoMC0xNCB0byBhdm9pZCBmdXR1cmUgZGF0ZXMpXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogNTkgfSksIC8vIG1pbnV0ZVxuICAgICAgICAoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IGAke3llYXJ9LSR7U3RyaW5nKG1vbnRoKS5wYWRTdGFydCgyLCAnMCcpfS0ke1N0cmluZyhkYXkpLnBhZFN0YXJ0KDIsICcwJyl9VCR7U3RyaW5nKGhvdXIpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKG1pbnV0ZSkucGFkU3RhcnQoMiwgJzAnKX06MDBaYDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTa2lwIGlmIGRhdGUgaXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIGlmIChuZXcgRGF0ZShkYXRlU3RyKSA+IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oZGF0ZVN0cik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IGZvcm1hdFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvTWF0Y2goL15cXGR7NH0tXFxkezJ9JC8pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZlcmlmeSB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgeWVhci1tb250aFxuICAgICAgICAgIGNvbnN0IFtyZXN1bHRZZWFyLCByZXN1bHRNb250aF0gPSByZXN1bHQuc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0WWVhcikudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgyMDIwKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0WWVhcikudG9CZUxlc3NUaGFuT3JFcXVhbCgyMDI2KTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0TW9udGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdE1vbnRoKS50b0JlTGVzc1RoYW5PckVxdWFsKDEyKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBJZGVtcG90ZW5jeVxuICAgKiBcbiAgICogQ2FsbGluZyBnZW5lcmF0ZURhdGVQYXJ0aXRpb24gbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBpbnB1dFxuICAgKiBzaG91bGQgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByZXN1bHQuXG4gICAqL1xuICBpdCgnc2hvdWxkIGJlIGlkZW1wb3RlbnQgKHNhbWUgaW5wdXQgYWx3YXlzIHByb2R1Y2VzIHNhbWUgb3V0cHV0KScsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzE5NzAtMDEtMDEnKSwgbWF4OiBuZXcgRGF0ZSgpIH0pLFxuICAgICAgICAoZGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzb1N0cmluZyA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQxID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKGlzb1N0cmluZyk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbihpc29TdHJpbmcpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdDMgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oaXNvU3RyaW5nKTtcbiAgICAgICAgICBcbiAgICAgICAgICBleHBlY3QocmVzdWx0MSkudG9CZShyZXN1bHQyKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0MikudG9CZShyZXN1bHQzKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBDb25zaXN0ZW5jeSB3aXRoIG1hbnVhbCBjYWxjdWxhdGlvblxuICAgKiBcbiAgICogVGhlIHJlc3VsdCBzaG91bGQgbWF0Y2ggYSBtYW51YWwgY2FsY3VsYXRpb24gb2YgSlNUIHllYXItbW9udGguXG4gICAqL1xuICBpdCgnc2hvdWxkIG1hdGNoIG1hbnVhbCBKU1QgeWVhci1tb250aCBjYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzE5NzAtMDEtMDEnKSwgbWF4OiBuZXcgRGF0ZSgpIH0pLFxuICAgICAgICAoZGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzb1N0cmluZyA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oaXNvU3RyaW5nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYW51YWwgY2FsY3VsYXRpb25cbiAgICAgICAgICBjb25zdCB1dGNEYXRlID0gbmV3IERhdGUoaXNvU3RyaW5nKTtcbiAgICAgICAgICBjb25zdCBqc3RUaW1lc3RhbXAgPSB1dGNEYXRlLmdldFRpbWUoKSArIDkgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgICBjb25zdCBqc3REYXRlID0gbmV3IERhdGUoanN0VGltZXN0YW1wKTtcbiAgICAgICAgICBjb25zdCBtYW51YWxZZWFyID0ganN0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIGNvbnN0IG1hbnVhbE1vbnRoID0gU3RyaW5nKGpzdERhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgY29uc3QgbWFudWFsUmVzdWx0ID0gYCR7bWFudWFsWWVhcn0tJHttYW51YWxNb250aH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUobWFudWFsUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBUaW1lem9uZSBvZmZzZXQgaGFuZGxpbmdcbiAgICogXG4gICAqIFRlc3RzIHRoYXQgZGF0ZXMgd2l0aCBleHBsaWNpdCB0aW1lem9uZSBvZmZzZXRzIGFyZSBjb3JyZWN0bHkgaGFuZGxlZC5cbiAgICovXG4gIGl0KCdzaG91bGQgaGFuZGxlIGRhdGVzIHdpdGggZXhwbGljaXQgdGltZXpvbmUgb2Zmc2V0cycsICgpID0+IHtcbiAgICAvLyBUZXN0IHdpdGggKzA5OjAwIG9mZnNldCAoSlNUKVxuICAgIGNvbnN0IGpzdERhdGUgPSAnMjAyNC0wMS0xNVQxMDozMDowMCswOTowMCc7XG4gICAgY29uc3QgcmVzdWx0MSA9IGdlbmVyYXRlRGF0ZVBhcnRpdGlvbihqc3REYXRlKTtcbiAgICBleHBlY3QocmVzdWx0MSkudG9CZSgnMjAyNC0wMScpO1xuXG4gICAgLy8gVGVzdCB3aXRoIC0wNTowMCBvZmZzZXQgKEVTVClcbiAgICBjb25zdCBlc3REYXRlID0gJzIwMjQtMDEtMTVUMTA6MzA6MDAtMDU6MDAnO1xuICAgIGNvbnN0IHJlc3VsdDIgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oZXN0RGF0ZSk7XG4gICAgLy8gRVNUIDEwOjMwID0gVVRDIDE1OjMwID0gSlNUIDAwOjMwIChuZXh0IGRheSlcbiAgICBleHBlY3QocmVzdWx0MikudG9CZSgnMjAyNC0wMScpO1xuXG4gICAgLy8gVGVzdCB3aXRoICswMDowMCBvZmZzZXQgKFVUQylcbiAgICBjb25zdCB1dGNEYXRlID0gJzIwMjQtMDEtMTVUMTA6MzA6MDArMDA6MDAnO1xuICAgIGNvbnN0IHJlc3VsdDMgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24odXRjRGF0ZSk7XG4gICAgZXhwZWN0KHJlc3VsdDMpLnRvQmUoJzIwMjQtMDEnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBNaWxsaXNlY29uZHMgcHJlY2lzaW9uXG4gICAqIFxuICAgKiBUZXN0cyB0aGF0IGRhdGVzIHdpdGggbWlsbGlzZWNvbmRzIGFyZSBjb3JyZWN0bHkgaGFuZGxlZC5cbiAgICovXG4gIGl0KCdzaG91bGQgaGFuZGxlIGRhdGVzIHdpdGggbWlsbGlzZWNvbmRzIHByZWNpc2lvbicsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzE5NzAtMDEtMDEnKSwgbWF4OiBuZXcgRGF0ZSgpIH0pLFxuICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDk5OSB9KSwgLy8gbWlsbGlzZWNvbmRzXG4gICAgICAgIChkYXRlLCBtcykgPT4ge1xuICAgICAgICAgIC8vIENyZWF0ZSBJU08gc3RyaW5nIHdpdGggbWlsbGlzZWNvbmRzXG4gICAgICAgICAgY29uc3QgYmFzZUlzbyA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCBpc29XaXRoTXMgPSBiYXNlSXNvLnJlcGxhY2UoL1xcLlxcZHszfVokLywgYC4ke1N0cmluZyhtcykucGFkU3RhcnQoMywgJzAnKX1aYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKGlzb1dpdGhNcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IGZvcm1hdFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvTWF0Y2goL15cXGR7NH0tXFxkezJ9JC8pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBzaG91bGQgbm90IGFmZmVjdCB0aGUgeWVhci1tb250aCByZXN1bHRcbiAgICAgICAgICBjb25zdCByZXN1bHRXaXRob3V0TXMgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24oYmFzZUlzbyk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShyZXN1bHRXaXRob3V0TXMpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAwIH1cbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogUHJvcGVydHk6IERldGVybWluaXN0aWMgb3V0cHV0IGZvciBzYW1lIFVUQyB0aW1lc3RhbXBcbiAgICogXG4gICAqIERpZmZlcmVudCByZXByZXNlbnRhdGlvbnMgb2YgdGhlIHNhbWUgVVRDIHRpbWVzdGFtcCBzaG91bGQgcHJvZHVjZVxuICAgKiB0aGUgc2FtZSBkYXRlX3BhcnRpdGlvbi5cbiAgICovXG4gIGl0KCdzaG91bGQgcHJvZHVjZSBzYW1lIHJlc3VsdCBmb3IgZXF1aXZhbGVudCBVVEMgdGltZXN0YW1wcycsICgpID0+IHtcbiAgICAvLyBTYW1lIG1vbWVudCBpbiB0aW1lLCBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb25zXG4gICAgY29uc3QgdXRjWiA9ICcyMDI0LTAxLTE1VDEwOjMwOjAwWic7XG4gICAgY29uc3QgdXRjT2Zmc2V0ID0gJzIwMjQtMDEtMTVUMTA6MzA6MDArMDA6MDAnO1xuICAgIGNvbnN0IGpzdE9mZnNldCA9ICcyMDI0LTAxLTE1VDE5OjMwOjAwKzA5OjAwJztcbiAgICBcbiAgICBjb25zdCByZXN1bHQxID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKHV0Y1opO1xuICAgIGNvbnN0IHJlc3VsdDIgPSBnZW5lcmF0ZURhdGVQYXJ0aXRpb24odXRjT2Zmc2V0KTtcbiAgICBjb25zdCByZXN1bHQzID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKGpzdE9mZnNldCk7XG4gICAgXG4gICAgZXhwZWN0KHJlc3VsdDEpLnRvQmUocmVzdWx0Mik7XG4gICAgZXhwZWN0KHJlc3VsdDIpLnRvQmUocmVzdWx0Myk7XG4gICAgZXhwZWN0KHJlc3VsdDEpLnRvQmUoJzIwMjQtMDEnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBIYW5kbGVzIGFsbCB2YWxpZCBob3VycyAoMC0yMylcbiAgICogXG4gICAqIFZlcmlmaWVzIGNvcnJlY3QgYmVoYXZpb3IgYWNyb3NzIGFsbCBob3VycyBvZiB0aGUgZGF5LlxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgaGFuZGxlIGFsbCBob3VycyBvZiB0aGUgZGF5JywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDIzIH0pLCAvLyBob3VyXG4gICAgICAgIChob3VyKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IGAyMDI0LTAxLTE1VCR7U3RyaW5nKGhvdXIpLnBhZFN0YXJ0KDIsICcwJyl9OjMwOjAwWmA7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVEYXRlUGFydGl0aW9uKGRhdGVTdHIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBleHBlY3RlZCByZXN1bHRcbiAgICAgICAgICBjb25zdCB1dGNEYXRlID0gbmV3IERhdGUoZGF0ZVN0cik7XG4gICAgICAgICAgY29uc3QganN0RGF0ZSA9IG5ldyBEYXRlKHV0Y0RhdGUuZ2V0VGltZSgpICsgOSAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZE1vbnRoID0gU3RyaW5nKGpzdERhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRZZWFyID0ganN0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoYCR7ZXhwZWN0ZWRZZWFyfS0ke2V4cGVjdGVkTW9udGh9YCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDI0IH0gLy8gVGVzdCBhbGwgMjQgaG91cnNcbiAgICApO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9
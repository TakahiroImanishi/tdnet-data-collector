{"file":"C:\\Users\\ti198\\investment_analysis_opopo\\src\\utils\\__tests__\\rate-limiter.property.test.ts","mappings":"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","names":[],"sources":["C:\\Users\\ti198\\investment_analysis_opopo\\src\\utils\\__tests__\\rate-limiter.property.test.ts"],"sourcesContent":["/**\r\n * RateLimiter - プロパティベーステスト\r\n * \r\n * fast-checkを使用して、任意の回数のリクエストに対して\r\n * レート制限が遵守されることを検証する。\r\n */\r\n\r\nimport * as fc from 'fast-check';\r\nimport { RateLimiter } from '../rate-limiter';\r\n\r\ndescribe('RateLimiter - Property Tests', () => {\r\n    /**\r\n     * Property 12: レート制限の遵守\r\n     * \r\n     * 任意の回数のリクエストに対して、連続リクエスト間で\r\n     * 最小遅延時間が確保されることを検証する。\r\n     * \r\n     * Steering準拠: development/testing-strategy.md\r\n     * - 最低100回の反復実行（推奨1000回）\r\n     * \r\n     * 検証内容:\r\n     * - リクエスト回数: 2-5回（テスト時間を考慮して削減）\r\n     * - 最小遅延時間: 50-200ms（テスト用に短縮）\r\n     * - 連続リクエスト間の遅延時間が最小遅延時間以上であること\r\n     * - 50msの誤差を許容（システムの処理時間を考慮）\r\n     */\r\n    it('Property 12: レート制限の遵守 - 連続リクエスト間で最小遅延時間が確保される', async () => {\r\n        await fc.assert(\r\n            fc.asyncProperty(\r\n                fc.integer({ min: 2, max: 5 }), // リクエスト回数（テスト時間を考慮）\r\n                fc.integer({ min: 50, max: 200 }), // 最小遅延時間（テスト用に短縮）\r\n                async (requestCount, minDelayMs) => {\r\n                    const rateLimiter = new RateLimiter({ minDelayMs });\r\n                    const timestamps: number[] = [];\r\n\r\n                    // 指定回数のリクエストを実行\r\n                    for (let i = 0; i < requestCount; i++) {\r\n                        await rateLimiter.waitIfNeeded();\r\n                        timestamps.push(Date.now());\r\n                    }\r\n\r\n                    // 連続リクエスト間の遅延時間を検証\r\n                    for (let i = 1; i < timestamps.length; i++) {\r\n                        const delay = timestamps[i] - timestamps[i - 1];\r\n                        \r\n                        // 最小遅延時間以上であることを確認（50msの誤差を許容）\r\n                        expect(delay).toBeGreaterThanOrEqual(minDelayMs - 50);\r\n                    }\r\n                }\r\n            ),\r\n            { numRuns: 100 } // Steering推奨: 最低100回反復実行\r\n        );\r\n    }, 120000); // タイムアウト: 120秒（反復回数増加に対応）\r\n\r\n    /**\r\n     * 最初のリクエストは即座に実行される\r\n     * \r\n     * 検証内容:\r\n     * - 最初のリクエストは待機時間なしで実行される\r\n     * - 実行時間が100ms以内であること\r\n     */\r\n    it('最初のリクエストは即座に実行される', async () => {\r\n        const rateLimiter = new RateLimiter({ minDelayMs: 2000 });\r\n        const start = Date.now();\r\n        await rateLimiter.waitIfNeeded();\r\n        const elapsed = Date.now() - start;\r\n        \r\n        expect(elapsed).toBeLessThan(100); // 100ms以内\r\n        expect(rateLimiter.getLastRequestTime()).not.toBeNull();\r\n    });\r\n\r\n    /**\r\n     * 2回目のリクエストは最小遅延時間後に実行される\r\n     * \r\n     * 検証内容:\r\n     * - 2回目のリクエストは最小遅延時間だけ待機する\r\n     * - 実際の遅延時間が最小遅延時間±100ms以内であること\r\n     */\r\n    it('2回目のリクエストは最小遅延時間後に実行される', async () => {\r\n        const minDelayMs = 500; // テスト用に短縮\r\n        const rateLimiter = new RateLimiter({ minDelayMs });\r\n        \r\n        await rateLimiter.waitIfNeeded(); // 最初のリクエスト\r\n        const start = Date.now();\r\n        await rateLimiter.waitIfNeeded(); // 2回目のリクエスト\r\n        const elapsed = Date.now() - start;\r\n        \r\n        // 最小遅延時間以上であることを確認（50msの誤差を許容）\r\n        expect(elapsed).toBeGreaterThanOrEqual(minDelayMs - 50);\r\n        // 最小遅延時間+100ms以内であることを確認\r\n        expect(elapsed).toBeLessThan(minDelayMs + 100);\r\n    });\r\n\r\n    /**\r\n     * reset()後は即座に実行される\r\n     * \r\n     * 検証内容:\r\n     * - reset()を呼び出すと、最後のリクエスト時刻がリセットされる\r\n     * - リセット後の最初のリクエストは即座に実行される\r\n     */\r\n    it('reset()後は即座に実行される', async () => {\r\n        const rateLimiter = new RateLimiter({ minDelayMs: 2000 });\r\n        \r\n        await rateLimiter.waitIfNeeded(); // 最初のリクエスト\r\n        expect(rateLimiter.getLastRequestTime()).not.toBeNull();\r\n        \r\n        rateLimiter.reset(); // リセット\r\n        expect(rateLimiter.getLastRequestTime()).toBeNull();\r\n        \r\n        const start = Date.now();\r\n        await rateLimiter.waitIfNeeded(); // リセット後の最初のリクエスト\r\n        const elapsed = Date.now() - start;\r\n        \r\n        expect(elapsed).toBeLessThan(100); // 100ms以内\r\n        expect(rateLimiter.getLastRequestTime()).not.toBeNull();\r\n    });\r\n\r\n    /**\r\n     * 複数回のリクエストで累積遅延時間が正しい\r\n     * \r\n     * 検証内容:\r\n     * - 3回のリクエストで、合計遅延時間が最小遅延時間×2以上であること\r\n     * - 最初のリクエストは即座に実行されるため、遅延は2回分\r\n     */\r\n    it('複数回のリクエストで累積遅延時間が正しい', async () => {\r\n        const minDelayMs = 300; // テスト用に短縮\r\n        const rateLimiter = new RateLimiter({ minDelayMs });\r\n        \r\n        const start = Date.now();\r\n        await rateLimiter.waitIfNeeded(); // 1回目（即座）\r\n        await rateLimiter.waitIfNeeded(); // 2回目（300ms待機）\r\n        await rateLimiter.waitIfNeeded(); // 3回目（300ms待機）\r\n        const elapsed = Date.now() - start;\r\n        \r\n        // 合計遅延時間が最小遅延時間×2以上であることを確認（100msの誤差を許容）\r\n        expect(elapsed).toBeGreaterThanOrEqual(minDelayMs * 2 - 100);\r\n    });\r\n\r\n    /**\r\n     * getMinDelayMs()が正しい値を返す\r\n     * \r\n     * 検証内容:\r\n     * - コンストラクタで指定した最小遅延時間が取得できること\r\n     */\r\n    it('getMinDelayMs()が正しい値を返す', () => {\r\n        const minDelayMs = 2000;\r\n        const rateLimiter = new RateLimiter({ minDelayMs });\r\n        \r\n        expect(rateLimiter.getMinDelayMs()).toBe(minDelayMs);\r\n    });\r\n\r\n    /**\r\n     * デフォルト値が正しく設定される\r\n     * \r\n     * 検証内容:\r\n     * - オプションを指定しない場合、デフォルト値（2000ms）が使用されること\r\n     */\r\n    it('デフォルト値が正しく設定される', () => {\r\n        const rateLimiter = new RateLimiter();\r\n        \r\n        expect(rateLimiter.getMinDelayMs()).toBe(2000);\r\n        expect(rateLimiter.getLastRequestTime()).toBeNull();\r\n    });\r\n\r\n    /**\r\n     * 並行実行時のレート制限\r\n     * \r\n     * 検証内容:\r\n     * - 複数のRateLimiterインスタンスは独立して動作すること\r\n     * - 各インスタンスが独自のレート制限を持つこと\r\n     */\r\n    it('並行実行時のレート制限', async () => {\r\n        const minDelayMs = 300; // テスト用に短縮\r\n        const rateLimiter1 = new RateLimiter({ minDelayMs });\r\n        const rateLimiter2 = new RateLimiter({ minDelayMs });\r\n        \r\n        const start = Date.now();\r\n        \r\n        // 並行実行\r\n        await Promise.all([\r\n            (async () => {\r\n                await rateLimiter1.waitIfNeeded();\r\n                await rateLimiter1.waitIfNeeded();\r\n            })(),\r\n            (async () => {\r\n                await rateLimiter2.waitIfNeeded();\r\n                await rateLimiter2.waitIfNeeded();\r\n            })(),\r\n        ]);\r\n        \r\n        const elapsed = Date.now() - start;\r\n        \r\n        // 並行実行のため、合計時間は単一インスタンスの2回分程度\r\n        expect(elapsed).toBeGreaterThanOrEqual(minDelayMs - 50);\r\n        expect(elapsed).toBeLessThan(minDelayMs * 2 + 200);\r\n    });\r\n});\r\n"],"version":3}
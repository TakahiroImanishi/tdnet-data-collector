0d8fea7adc4db2f70779758f6bcee09c
"use strict";
/**
 * TDnet List Scraper - Unit Tests
 *
 * Requirements: 要件1.1, 9.1
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Mock dependencies BEFORE importing the module under test
jest.mock('axios');
jest.mock('../../../scraper/html-parser');
jest.mock('../../../utils/rate-limiter');
jest.mock('../../../utils/rate-limiter', () => {
    return {
        RateLimiter: jest.fn().mockImplementation(() => ({
            waitIfNeeded: mockWaitIfNeeded,
            reset: mockReset,
            getMinDelayMs: mockGetMinDelayMs,
            getLastRequestTime: mockGetLastRequestTime,
        })),
    };
});
/**
 * TDnet List Scraper - Unit Tests
 *
 * Requirements: 要件1.1, 9.1
 */
const axios_1 = __importDefault(require("axios"));
const html_parser_1 = require("../../../scraper/html-parser");
const errors_1 = require("../../../errors");
// Mock RateLimiter with a factory function
const mockWaitIfNeeded = jest.fn().mockResolvedValue(undefined);
const mockReset = jest.fn();
const mockGetMinDelayMs = jest.fn().mockReturnValue(2000);
const mockGetLastRequestTime = jest.fn().mockReturnValue(null);
// NOW import the module under test (after mocks are set up)
const scrape_tdnet_list_1 = require("../scrape-tdnet-list");
const mockAxios = axios_1.default;
const mockParseDisclosureList = html_parser_1.parseDisclosureList;
describe('scrapeTdnetList', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe('Success Cases', () => {
        it('should successfully scrape TDnet list', async () => {
            const mockHtml = '<html><body>Test HTML</body></html>';
            const mockDisclosures = [
                {
                    company_code: '1234',
                    company_name: 'Test Company',
                    disclosure_type: '決算短信',
                    title: 'Test Disclosure',
                    disclosed_at: '2024-01-15T01:30:00Z',
                    pdf_url: 'https://example.com/test.pdf',
                },
            ];
            mockAxios.get.mockResolvedValue({
                data: mockHtml,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue(mockDisclosures);
            const result = await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(result).toEqual(mockDisclosures);
            expect(mockWaitIfNeeded).toHaveBeenCalled();
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('2024-01-15'), expect.objectContaining({
                timeout: 30000,
                headers: expect.objectContaining({
                    'User-Agent': expect.stringContaining('TDnet-Data-Collector'),
                }),
            }));
            expect(mockParseDisclosureList).toHaveBeenCalledWith(mockHtml);
        });
        it('should apply rate limiting before each request', async () => {
            const mockHtml = '<html><body>Test HTML</body></html>';
            mockAxios.get.mockResolvedValue({
                data: mockHtml,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            // Verify rate limiter was called
            expect(mockWaitIfNeeded).toHaveBeenCalled();
            // Verify axios.get was called after rate limiter
            expect(mockAxios.get).toHaveBeenCalled();
        });
    });
    describe('Validation', () => {
        describe('Date Format Validation', () => {
            it('should reject invalid date format - slash separator', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024/01/15')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024/01/15')).rejects.toThrow('Expected YYYY-MM-DD format');
            });
            it('should reject invalid date format - no separator', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('20240115')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('20240115')).rejects.toThrow('Expected YYYY-MM-DD format');
            });
            it('should reject invalid date format - single digit month/day', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-1-15')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-5')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-1-5')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject invalid date format - extra characters', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15T00:00:00')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15 ')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(' 2024-01-15')).rejects.toThrow(errors_1.ValidationError);
            });
        });
        describe('Non-Existent Date Validation', () => {
            it('should reject February 30th', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-30')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-30')).rejects.toThrow('Date does not exist');
            });
            it('should reject February 29th in non-leap year', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-29')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-29')).rejects.toThrow('Date does not exist');
            });
            it('should accept February 29th in leap year', async () => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-29')).resolves.not.toThrow();
            });
            it('should reject invalid month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-13-01')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-00-01')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject invalid day', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-32')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-00')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject April 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-04-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject June 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-06-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject September 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-09-31')).rejects.toThrow(errors_1.ValidationError);
            });
            it('should reject November 31st (30-day month)', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-11-31')).rejects.toThrow(errors_1.ValidationError);
            });
        });
        describe('Date Range Validation', () => {
            it('should reject dates before 1970-01-01', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1969-12-31')).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1969-12-31')).rejects.toThrow('Must be on or after 1970-01-01');
            });
            it('should accept 1970-01-01', async () => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('1970-01-01')).resolves.not.toThrow();
            });
            it('should reject dates more than 1 day in the future', async () => {
                const futureDate = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);
                const futureDateStr = futureDate.toISOString().split('T')[0];
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(futureDateStr)).rejects.toThrow(errors_1.ValidationError);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(futureDateStr)).rejects.toThrow('Must be within 1 day of current date');
            });
            it('should accept today\'s date', async () => {
                const today = new Date().toISOString().split('T')[0];
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(today)).resolves.not.toThrow();
            });
            it('should accept tomorrow\'s date (within 1 day)', async () => {
                const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);
                const tomorrowStr = tomorrow.toISOString().split('T')[0];
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)(tomorrowStr)).resolves.not.toThrow();
            });
        });
        describe('Valid Date Acceptance', () => {
            beforeEach(() => {
                mockAxios.get.mockResolvedValue({
                    data: '<html></html>',
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
                mockParseDisclosureList.mockReturnValue([]);
            });
            it('should accept valid date format', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-12-31')).resolves.not.toThrow();
            });
            it('should accept first day of month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-01')).resolves.not.toThrow();
            });
            it('should accept last day of 31-day month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-31')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-03-31')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-05-31')).resolves.not.toThrow();
            });
            it('should accept last day of 30-day month', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-04-30')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-06-30')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-09-30')).resolves.not.toThrow();
            });
            it('should accept February 28th', async () => {
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-02-28')).resolves.not.toThrow();
                await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2023-02-28')).resolves.not.toThrow();
            });
        });
    });
    describe('Error Handling', () => {
        it('should retry on network errors', async () => {
            const networkError = new Error('ECONNRESET');
            networkError.code = 'ECONNRESET';
            mockAxios.get
                .mockRejectedValueOnce(networkError)
                .mockRejectedValueOnce(networkError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(3);
        });
        it('should retry on timeout errors', async () => {
            const timeoutError = new Error('timeout of 30000ms exceeded');
            timeoutError.code = 'ECONNABORTED';
            mockAxios.get
                .mockRejectedValueOnce(timeoutError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should retry on 5xx errors', async () => {
            const serverError = {
                response: {
                    status: 503,
                    statusText: 'Service Unavailable',
                    data: 'Service Unavailable',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get
                .mockRejectedValueOnce(serverError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should retry on 429 rate limit errors', async () => {
            const rateLimitError = {
                response: {
                    status: 429,
                    statusText: 'Too Many Requests',
                    data: 'Rate limit exceeded',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get
                .mockRejectedValueOnce(rateLimitError)
                .mockResolvedValueOnce({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledTimes(2);
        });
        it('should not retry on 404 errors', async () => {
            const notFoundError = {
                response: {
                    status: 404,
                    statusText: 'Not Found',
                    data: 'Page not found',
                    headers: {},
                    config: {},
                },
                isAxiosError: true,
            };
            mockAxios.get.mockRejectedValue(notFoundError);
            await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).rejects.toThrow(errors_1.ValidationError);
            expect(mockAxios.get).toHaveBeenCalledTimes(1);
        });
        it('should fail after max retries', async () => {
            const networkError = new Error('ECONNRESET');
            networkError.code = 'ECONNRESET';
            mockAxios.get.mockRejectedValue(networkError);
            await expect((0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15')).rejects.toThrow();
            expect(mockAxios.get).toHaveBeenCalledTimes(4); // 1 initial + 3 retries
        });
    });
    describe('URL Construction', () => {
        it('should construct correct TDnet URL', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('I_list_001_2024-01-15.html'), expect.any(Object));
        });
        it('should use custom base URL from environment variable', async () => {
            const originalEnv = process.env.TDNET_BASE_URL;
            process.env.TDNET_BASE_URL = 'https://custom.tdnet.url';
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.stringContaining('https://custom.tdnet.url'), expect.any(Object));
            // Restore original environment
            if (originalEnv) {
                process.env.TDNET_BASE_URL = originalEnv;
            }
            else {
                delete process.env.TDNET_BASE_URL;
            }
        });
    });
    describe('HTTP Headers', () => {
        it('should include proper User-Agent header', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                headers: expect.objectContaining({
                    'User-Agent': expect.stringContaining('TDnet-Data-Collector'),
                }),
            }));
        });
        it('should include Accept and Accept-Language headers', async () => {
            mockAxios.get.mockResolvedValue({
                data: '<html></html>',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            });
            mockParseDisclosureList.mockReturnValue([]);
            await (0, scrape_tdnet_list_1.scrapeTdnetList)('2024-01-15');
            expect(mockAxios.get).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                headers: expect.objectContaining({
                    'Accept': expect.stringContaining('text/html'),
                    'Accept-Language': expect.stringContaining('ja'),
                }),
            }));
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aTE5OFxcaW52ZXN0bWVudF9hbmFseXNpc19vcG9wb1xcc3JjXFxsYW1iZGFcXGNvbGxlY3RvclxcX190ZXN0c19fXFxzY3JhcGUtdGRuZXQtbGlzdC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7OztBQVlILDJEQUEyRDtBQUMzRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFRekMsSUFBSSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7SUFDNUMsT0FBTztRQUNMLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUMvQyxZQUFZLEVBQUUsZ0JBQWdCO1lBQzlCLEtBQUssRUFBRSxTQUFTO1lBQ2hCLGFBQWEsRUFBRSxpQkFBaUI7WUFDaEMsa0JBQWtCLEVBQUUsc0JBQXNCO1NBQzNDLENBQUMsQ0FBQztLQUNKLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQTlCSDs7OztHQUlHO0FBRUgsa0RBQTBCO0FBQzFCLDhEQUFtRTtBQUNuRSw0Q0FBa0Q7QUFPbEQsMkNBQTJDO0FBQzNDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hFLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUM1QixNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUQsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBYS9ELDREQUE0RDtB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dF9hbmFseXNpc19vcG9wb1xcc3JjXFxsYW1iZGFcXGNvbGxlY3RvclxcX190ZXN0c19fXFxzY3JhcGUtdGRuZXQtbGlzdC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBURG5ldCBMaXN0IFNjcmFwZXIgLSBVbml0IFRlc3RzXHJcbiAqXHJcbiAqIFJlcXVpcmVtZW50czog6KaB5Lu2MS4xLCA5LjFcclxuICovXHJcblxyXG4vKipcclxuICogVERuZXQgTGlzdCBTY3JhcGVyIC0gVW5pdCBUZXN0c1xyXG4gKlxyXG4gKiBSZXF1aXJlbWVudHM6IOimgeS7tjEuMSwgOS4xXHJcbiAqL1xyXG5cclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IHsgcGFyc2VEaXNjbG9zdXJlTGlzdCB9IGZyb20gJy4uLy4uLy4uL3NjcmFwZXIvaHRtbC1wYXJzZXInO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9lcnJvcnMnO1xyXG5cclxuLy8gTW9jayBkZXBlbmRlbmNpZXMgQkVGT1JFIGltcG9ydGluZyB0aGUgbW9kdWxlIHVuZGVyIHRlc3RcclxuamVzdC5tb2NrKCdheGlvcycpO1xyXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NjcmFwZXIvaHRtbC1wYXJzZXInKTtcclxuamVzdC5tb2NrKCcuLi8uLi8uLi91dGlscy9yYXRlLWxpbWl0ZXInKTtcclxuXHJcbi8vIE1vY2sgUmF0ZUxpbWl0ZXIgd2l0aCBhIGZhY3RvcnkgZnVuY3Rpb25cclxuY29uc3QgbW9ja1dhaXRJZk5lZWRlZCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5jb25zdCBtb2NrUmVzZXQgPSBqZXN0LmZuKCk7XHJcbmNvbnN0IG1vY2tHZXRNaW5EZWxheU1zID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgyMDAwKTtcclxuY29uc3QgbW9ja0dldExhc3RSZXF1ZXN0VGltZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XHJcblxyXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3V0aWxzL3JhdGUtbGltaXRlcicsICgpID0+IHtcclxuICByZXR1cm4ge1xyXG4gICAgUmF0ZUxpbWl0ZXI6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcclxuICAgICAgd2FpdElmTmVlZGVkOiBtb2NrV2FpdElmTmVlZGVkLFxyXG4gICAgICByZXNldDogbW9ja1Jlc2V0LFxyXG4gICAgICBnZXRNaW5EZWxheU1zOiBtb2NrR2V0TWluRGVsYXlNcyxcclxuICAgICAgZ2V0TGFzdFJlcXVlc3RUaW1lOiBtb2NrR2V0TGFzdFJlcXVlc3RUaW1lLFxyXG4gICAgfSkpLFxyXG4gIH07XHJcbn0pO1xyXG5cclxuLy8gTk9XIGltcG9ydCB0aGUgbW9kdWxlIHVuZGVyIHRlc3QgKGFmdGVyIG1vY2tzIGFyZSBzZXQgdXApXHJcbmltcG9ydCB7IHNjcmFwZVRkbmV0TGlzdCB9IGZyb20gJy4uL3NjcmFwZS10ZG5ldC1saXN0JztcclxuXHJcbmNvbnN0IG1vY2tBeGlvcyA9IGF4aW9zIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBheGlvcz47XHJcbmNvbnN0IG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0ID0gcGFyc2VEaXNjbG9zdXJlTGlzdCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBwYXJzZURpc2Nsb3N1cmVMaXN0PjtcclxuXHJcbmRlc2NyaWJlKCdzY3JhcGVUZG5ldExpc3QnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1N1Y2Nlc3MgQ2FzZXMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBzY3JhcGUgVERuZXQgbGlzdCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja0h0bWwgPSAnPGh0bWw+PGJvZHk+VGVzdCBIVE1MPC9ib2R5PjwvaHRtbD4nO1xyXG4gICAgICBjb25zdCBtb2NrRGlzY2xvc3VyZXMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY29tcGFueV9jb2RlOiAnMTIzNCcsXHJcbiAgICAgICAgICBjb21wYW55X25hbWU6ICdUZXN0IENvbXBhbnknLFxyXG4gICAgICAgICAgZGlzY2xvc3VyZV90eXBlOiAn5rG6566X55+t5L+hJyxcclxuICAgICAgICAgIHRpdGxlOiAnVGVzdCBEaXNjbG9zdXJlJyxcclxuICAgICAgICAgIGRpc2Nsb3NlZF9hdDogJzIwMjQtMDEtMTVUMDE6MzA6MDBaJyxcclxuICAgICAgICAgIHBkZl91cmw6ICdodHRwczovL2V4YW1wbGUuY29tL3Rlc3QucGRmJyxcclxuICAgICAgICB9LFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogbW9ja0h0bWwsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUobW9ja0Rpc2Nsb3N1cmVzKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRGlzY2xvc3VyZXMpO1xyXG4gICAgICBleHBlY3QobW9ja1dhaXRJZk5lZWRlZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJzIwMjQtMDEtMTUnKSxcclxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcclxuICAgICAgICAgIGhlYWRlcnM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVERuZXQtRGF0YS1Db2xsZWN0b3InKSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICAgIGV4cGVjdChtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0h0bWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBhcHBseSByYXRlIGxpbWl0aW5nIGJlZm9yZSBlYWNoIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tIdG1sID0gJzxodG1sPjxib2R5PlRlc3QgSFRNTDwvYm9keT48L2h0bWw+JztcclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogbW9ja0h0bWwsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgfSk7XHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSByYXRlIGxpbWl0ZXIgd2FzIGNhbGxlZFxyXG4gICAgICBleHBlY3QobW9ja1dhaXRJZk5lZWRlZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICAvLyBWZXJpZnkgYXhpb3MuZ2V0IHdhcyBjYWxsZWQgYWZ0ZXIgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1ZhbGlkYXRpb24nLCAoKSA9PiB7XHJcbiAgICBkZXNjcmliZSgnRGF0ZSBGb3JtYXQgVmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBkYXRlIGZvcm1hdCAtIHNsYXNoIHNlcGFyYXRvcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LzAxLzE1JykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQvMDEvMTUnKSkucmVqZWN0cy50b1Rocm93KCdFeHBlY3RlZCBZWVlZLU1NLUREIGZvcm1hdCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZGF0ZSBmb3JtYXQgLSBubyBzZXBhcmF0b3InLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNDAxMTUnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNDAxMTUnKSkucmVqZWN0cy50b1Rocm93KCdFeHBlY3RlZCBZWVlZLU1NLUREIGZvcm1hdCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZGF0ZSBmb3JtYXQgLSBzaW5nbGUgZGlnaXQgbW9udGgvZGF5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMS0xNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTUnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0xLTUnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBkYXRlIGZvcm1hdCAtIGV4dHJhIGNoYXJhY3RlcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNVQwMDowMDowMCcpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1ICcpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcgMjAyNC0wMS0xNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnTm9uLUV4aXN0ZW50IERhdGUgVmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgRmVicnVhcnkgMzB0aCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAyLTMwJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDItMzAnKSkucmVqZWN0cy50b1Rocm93KCdEYXRlIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgRmVicnVhcnkgMjl0aCBpbiBub24tbGVhcCB5ZWFyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjMtMDItMjknKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyMy0wMi0yOScpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGUgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIGFjY2VwdCBGZWJydWFyeSAyOXRoIGluIGxlYXAgeWVhcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMi0yOScpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgbW9udGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0xMy0wMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAwLTAxJykpLnJlamVjdHMudG9UaHJvdyhWYWxpZGF0aW9uRXJyb3IpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZGF5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMzInKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0wMCcpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBBcHJpbCAzMXN0ICgzMC1kYXkgbW9udGgpJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDQtMzEnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgSnVuZSAzMXN0ICgzMC1kYXkgbW9udGgpJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDYtMzEnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgU2VwdGVtYmVyIDMxc3QgKDMwLWRheSBtb250aCknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wOS0zMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBOb3ZlbWJlciAzMXN0ICgzMC1kYXkgbW9udGgpJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMTEtMzEnKSkucmVqZWN0cy50b1Rocm93KFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0RhdGUgUmFuZ2UgVmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgZGF0ZXMgYmVmb3JlIDE5NzAtMDEtMDEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMTk2OS0xMi0zMScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcxOTY5LTEyLTMxJykpLnJlamVjdHMudG9UaHJvdygnTXVzdCBiZSBvbiBvciBhZnRlciAxOTcwLTAxLTAxJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgMTk3MC0wMS0wMScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMTk3MC0wMS0wMScpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGRhdGVzIG1vcmUgdGhhbiAxIGRheSBpbiB0aGUgZnV0dXJlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZ1dHVyZURhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgMiAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IGZ1dHVyZURhdGVTdHIgPSBmdXR1cmVEYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuICAgICAgICBcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KGZ1dHVyZURhdGVTdHIpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KGZ1dHVyZURhdGVTdHIpKS5yZWplY3RzLnRvVGhyb3coJ011c3QgYmUgd2l0aGluIDEgZGF5IG9mIGN1cnJlbnQgZGF0ZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IHRvZGF5XFwncyBkYXRlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QodG9kYXkpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IHRvbW9ycm93XFwncyBkYXRlICh3aXRoaW4gMSBkYXkpJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvbW9ycm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIDI0ICogNjAgKiA2MCAqIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IHRvbW9ycm93U3RyID0gdG9tb3Jyb3cudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KHRvbW9ycm93U3RyKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnVmFsaWQgRGF0ZSBBY2NlcHRhbmNlJywgKCkgPT4ge1xyXG4gICAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIGFjY2VwdCB2YWxpZCBkYXRlIGZvcm1hdCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1JykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0xMi0zMScpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IGZpcnN0IGRheSBvZiBtb250aCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTAxJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCBhY2NlcHQgbGFzdCBkYXkgb2YgMzEtZGF5IG1vbnRoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMzEnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAzLTMxJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wNS0zMScpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgYWNjZXB0IGxhc3QgZGF5IG9mIDMwLWRheSBtb250aCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTA0LTMwJykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wNi0zMCcpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDktMzAnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIGFjY2VwdCBGZWJydWFyeSAyOHRoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDItMjgnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgICBhd2FpdCBleHBlY3Qoc2NyYXBlVGRuZXRMaXN0KCcyMDIzLTAyLTI4JykpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgcmV0cnkgb24gbmV0d29yayBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IG5ldyBFcnJvcignRUNPTk5SRVNFVCcpO1xyXG4gICAgICAobmV0d29ya0Vycm9yIGFzIGFueSkuY29kZSA9ICdFQ09OTlJFU0VUJztcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXRcclxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldHdvcmtFcnJvcilcclxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldHdvcmtFcnJvcilcclxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiB0aW1lb3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCd0aW1lb3V0IG9mIDMwMDAwbXMgZXhjZWVkZWQnKTtcclxuICAgICAgKHRpbWVvdXRFcnJvciBhcyBhbnkpLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXRcclxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHRpbWVvdXRFcnJvcilcclxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcclxuICAgICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiA1eHggZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBzZXJ2ZXJFcnJvciA9IHtcclxuICAgICAgICByZXNwb25zZToge1xyXG4gICAgICAgICAgc3RhdHVzOiA1MDMsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnU2VydmljZSBVbmF2YWlsYWJsZScsXHJcbiAgICAgICAgICBkYXRhOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNBeGlvc0Vycm9yOiB0cnVlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldFxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoc2VydmVyRXJyb3IpXHJcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XHJcbiAgICAgICAgICBkYXRhOiAnPGh0bWw+PC9odG1sPicsXHJcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgIGF3YWl0IHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0cnkgb24gNDI5IHJhdGUgbGltaXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCByYXRlTGltaXRFcnJvciA9IHtcclxuICAgICAgICByZXNwb25zZToge1xyXG4gICAgICAgICAgc3RhdHVzOiA0MjksXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnVG9vIE1hbnkgUmVxdWVzdHMnLFxyXG4gICAgICAgICAgZGF0YTogJ1JhdGUgbGltaXQgZXhjZWVkZWQnLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQXhpb3NFcnJvcjogdHJ1ZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXRcclxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHJhdGVMaW1pdEVycm9yKVxyXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xyXG4gICAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIG1vY2tQYXJzZURpc2Nsb3N1cmVMaXN0Lm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcblxyXG4gICAgICBhd2FpdCBzY3JhcGVUZG5ldExpc3QoJzIwMjQtMDEtMTUnKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrQXhpb3MuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSBvbiA0MDQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBub3RGb3VuZEVycm9yID0ge1xyXG4gICAgICAgIHJlc3BvbnNlOiB7XHJcbiAgICAgICAgICBzdGF0dXM6IDQwNCxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdOb3QgRm91bmQnLFxyXG4gICAgICAgICAgZGF0YTogJ1BhZ2Ugbm90IGZvdW5kJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0F4aW9zRXJyb3I6IHRydWUsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBtb2NrQXhpb3MuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5vdEZvdW5kRXJyb3IpO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpKS5yZWplY3RzLnRvVGhyb3coVmFsaWRhdGlvbkVycm9yKTtcclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgZmFpbCBhZnRlciBtYXggcmV0cmllcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKCdFQ09OTlJFU0VUJyk7XHJcbiAgICAgIChuZXR3b3JrRXJyb3IgYXMgYW55KS5jb2RlID0gJ0VDT05OUkVTRVQnO1xyXG5cclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXR3b3JrRXJyb3IpO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpKS5yZWplY3RzLnRvVGhyb3coKTtcclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTsgLy8gMSBpbml0aWFsICsgMyByZXRyaWVzXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1VSTCBDb25zdHJ1Y3Rpb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNvbnN0cnVjdCBjb3JyZWN0IFREbmV0IFVSTCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgIH0pO1xyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0lfbGlzdF8wMDFfMjAyNC0wMS0xNS5odG1sJyksXHJcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHVzZSBjdXN0b20gYmFzZSBVUkwgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudi5URE5FVF9CQVNFX1VSTDtcclxuICAgICAgcHJvY2Vzcy5lbnYuVERORVRfQkFTRV9VUkwgPSAnaHR0cHM6Ly9jdXN0b20udGRuZXQudXJsJztcclxuXHJcbiAgICAgIG1vY2tBeGlvcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgIGRhdGE6ICc8aHRtbD48L2h0bWw+JyxcclxuICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxyXG4gICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxyXG4gICAgICB9KTtcclxuICAgICAgbW9ja1BhcnNlRGlzY2xvc3VyZUxpc3QubW9ja1JldHVyblZhbHVlKFtdKTtcclxuXHJcbiAgICAgIGF3YWl0IHNjcmFwZVRkbmV0TGlzdCgnMjAyNC0wMS0xNScpO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tBeGlvcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdodHRwczovL2N1c3RvbS50ZG5ldC51cmwnKSxcclxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZW52aXJvbm1lbnRcclxuICAgICAgaWYgKG9yaWdpbmFsRW52KSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuVERORVRfQkFTRV9VUkwgPSBvcmlnaW5hbEVudjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuVERORVRfQkFTRV9VUkw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnSFRUUCBIZWFkZXJzJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHByb3BlciBVc2VyLUFnZW50IGhlYWRlcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgIH0pO1xyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxyXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgIGhlYWRlcnM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVERuZXQtRGF0YS1Db2xsZWN0b3InKSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgQWNjZXB0IGFuZCBBY2NlcHQtTGFuZ3VhZ2UgaGVhZGVycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F4aW9zLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgZGF0YTogJzxodG1sPjwvaHRtbD4nLFxyXG4gICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXHJcbiAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXHJcbiAgICAgIH0pO1xyXG4gICAgICBtb2NrUGFyc2VEaXNjbG9zdXJlTGlzdC5tb2NrUmV0dXJuVmFsdWUoW10pO1xyXG5cclxuICAgICAgYXdhaXQgc2NyYXBlVGRuZXRMaXN0KCcyMDI0LTAxLTE1Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0F4aW9zLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxyXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgIGhlYWRlcnM6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgICAgJ0FjY2VwdCc6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCd0ZXh0L2h0bWwnKSxcclxuICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdqYScpLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sInZlcnNpb24iOjN9